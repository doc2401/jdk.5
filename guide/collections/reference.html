<HTML>
<HEAD>
<title>Annotated Outline of the Collections Framework</title>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR>
<TD WIDTH=60>
   <IMG SRC="../../images/javalogo52x88.gif" ALT="Java" BORDER=0 WIDTH=52 HEIGHT=88>
</TD>

<TD>
<center>
  <h1>Annotated Outline of Collections Framework</h1>
</center>
</TD>

</TR>
</TABLE>

<!-- Body text begins here -->
The collections framework consists of:
<ul>
<li><strong>Collection Interfaces</strong> - The primary means by which
collections are manipulated.
<ul>
<li><a href="../../api/java/util/Collection.html"><strong>Collection</strong></a>
- A group of objects.  No assumptions are made about the order of
the collection (if any), or whether it may contain duplicate elements.

<li><a href="../../api/java/util/Set.html"><strong>Set</strong></a>
- The familiar set abstraction.  No duplicate elements permitted.  May
or may not be ordered.  Extends the <tt>Collection</tt> interface.

<li><a href="../../api/java/util/List.html"><strong>List</strong></a>
- Ordered collection, also known as a <i>sequence</i>. Duplicates are
generally permitted.  Allows positional access.  Extends the
<tt>Collection</tt> interface.

<li><a href="../../api/java/util/Queue.html"><strong>Queue</strong></a> -
A collection designed for holding elements prior to processing.
Besides basic <tt>Collection</tt> operations, queues provide
additional insertion, extraction, and inspection operations.

<li><a href="../../api/java/util/Map.html"><strong>Map</strong></a>
- A mapping from keys to values.  Each key can map to at most one value.

<li><a
href="../../api/java/util/SortedSet.html"><strong>SortedSet</strong></a>
- A set whose elements are automatically sorted, either in their
<i>natural ordering</i> (see the <a
href="../../api/java/lang/Comparable.html"><tt>Comparable</tt></a>
interface), or by a <a
href="../../api/java/util/Comparator.html"><tt>Comparator</tt></a>
object provided when a <tt>SortedSet</tt> instance is created.
Extends the <tt>Set</tt> interface.

<li><a
href="../../api/java/util/SortedMap.html"><strong>SortedMap</strong></a>
- A map whose mappings are automatically sorted by key, either in the
keys' <i>natural ordering</i> or by a comparator provided when a
<tt>SortedMap</tt> instance is created.  Extends the <tt>Map</tt>
interface.

<li><a
href="../../api/java/util/concurrent/BlockingQueue.html"><strong>BlockingQueue</strong></a>
- A <tt>Queue</tt> with operations that wait for the queue to become
non-empty when retrieving an element, and that wait for space to become
available in the queue when storing an element.  (This interface is part of
the package <tt><a href="../../api/java/util/concurrent/package-summary.html">java.util.concurrent</a></tt>.)

<li><a
href="../../api/java/util/concurrent/ConcurrentMap.html"><strong>ConcurrentMap</strong></a>
- A <tt>Map</tt> with atomic <tt>putIfAbsent</tt>, <tt>remove</tt>, and
<tt>replace</tt> methods.
(This interface is part of the package <tt>java.util.concurrent</tt>.)
</ul>

<li><strong>General-Purpose Implementations</strong> - The primary
implementations of the collection interfaces.
<ul>
<li><strong><a href="../../api/java/util/HashSet.html">HashSet</a>
</strong> - Hash table implementation of the <tt>Set</tt> interface.
The best all-around implementation of the <tt>Set</tt> interface.

<li>
<a href="../../api/java/util/TreeSet.html"><strong>TreeSet</strong></a>
Red-black tree implementation of the <tt>SortedSet</tt> interface.

<li><strong><a
href="../../api/java/util/LinkedHashSet.html">LinkedHashSet</a></strong> 
 - Hash table and linked list implementation of the <tt>Set</tt> interface.
An insertion-ordered <tt>Set</tt> implementation that runs nearly as fast as
<tt>HashSet</tt>.

<li><strong><a
href="../../api/java/util/ArrayList.html">ArrayList</a></strong> -
Resizable-array implementation of the <tt>List</tt> interface.
(Essentially an unsynchronized <tt>Vector</tt>.)  The best all-around
implementation of the <tt>List</tt> interface.

<li>
<a
href="../../api/java/util/LinkedList.html"><strong>LinkedList</strong></a>
- Doubly-linked list implementation of the <tt>List</tt> interface.
May provide better performance than the <tt>ArrayList</tt>
implementation if elements are frequently inserted or deleted within
the list.  Can be used as a double-ended queue (deque). Also implements the
<tt>Queue</tt> interface.  When accessed via the <tt>Queue</tt> interface,
<tt>LinkedList</tt> behaves as a FIFO queue.

<li><strong><a
href="../../api/java/util/PriorityQueue.html">PriorityQueue</a></strong> - 
Heap implementation of an unbounded priority queue.

<li><strong><a
href="../../api/java/util/HashMap.html">HashMap</a></strong> - Hash
table implementation of the <tt>Map</tt> interface. (Essentially an
unsynchronized <tt>Hashtable</tt> that supports <tt>null</tt> keys and
values.)  The best all-around implementation of the <tt>Map</tt>
interface.

<li>
<a href="../../api/java/util/TreeMap.html"><strong>TreeMap</strong></a>
Red-black tree implementation of the <tt>SortedMap</tt> interface.

<li><strong><a
href="../../api/java/util/LinkedHashMap.html">LinkedHashMap</a></strong> 
 - Hash table and linked list implementation of the <tt>Map</tt> interface.
An insertion-ordered <tt>Map</tt> implementation that runs nearly as fast as
<tt>HashMap</tt>.  Also useful for building caches (see 
<a
href="../../api/java/util/LinkedHashMap.html#removeEldestEntry(java.util.Map.Entry)">removeEldestEntry(Map.Entry)</a>
).

</ul>

<li><strong>Wrapper Implementations</strong> - Functionality-enhancing
implementations for use with other implementations.  Accessed solely
through static factory methods.
<ul>
<li>
<a
href="../../api/java/util/Collections.html#unmodifiableCollection(java.util.Collection)"><strong>Collections.unmodifiable<i>Interface</i></strong></a>
- Return an unmodifiable view of a specified collection that throws an
<tt>UnsupportedOperationException</tt> if the user attempts to modify
it.

<li>
<a name="synchWrappers"
href="../../api/java/util/Collections.html#synchronizedCollection(java.util.Collection)">
<strong>Collections.synchronized<i>Interface</i></strong></a> - Return
a synchronized collection that is backed by the specified (typically
unsynchronized) collection.  As long as all accesses to the backing
collection are through the returned collection, thread-safety is
guaranteed.

<li>
<a href="../../api/java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><strong>Collections.checked<i>Interface</i></strong></a>
 - Return a dynamically typesafe view of the specified collection, which
throws a <tt>ClassCastException</tt> if a client attempts to add an element of
the wrong type.  The generics mechanism in the language provides compile-time
(static) type checking, but it is possible to defeat this mechanism.
Dynamically typesafe views eliminate this possibility entirely.

</ul>

<li><strong>Convenience Implementations</strong> - High-performance
"mini-implementations" of the collection interfaces.
<ul>
<li>
<a
href="../../api/java/util/Arrays.html#asList(T...)"><strong>Arrays.asList</strong></a>
- Allows an array to be viewed as a list.

<li><strong><a href="../../api/java/util/Collections.html#EMPTY_SET">EMPTY_SET</a>,
<a href="../../api/java/util/Collections.html#EMPTY_LIST">EMPTY_LIST</a>
and <a href="../../api/java/util/Collections.html#EMPTY_MAP">EMPTY_MAP</a>
</strong> - Constants representing the empty set and list (immutable).

<li><strong>
<a href="../../api/java/util/Collections.html#singleton(java.lang.Object)">singleton</a>,
<a href="../../api/java/util/Collections.html#singletonList(java.lang.Object)">singletonList</a>,
and <a href="../../api/java/util/Collections.html#singletonMap(K, V)">singletonMap</a>
</strong> - Returns an immutable "singleton" set, list, or map, containing only the specified object (or key-value mapping).
<li>
<a href="../../api/java/util/Collections.html#nCopies(int, T)"><strong>nCopies</strong></a>
- Returns an immutable list consisting of n copies of a specified object.
</ul>

<li><strong>Legacy Implementations</strong> - Older collection classes have
been retrofitted to implement the collection interfaces.
<ul>
<li>
<a href="../../api/java/util/Vector.html"><strong>Vector</strong></a>
- Synchronized resizable-array implementation of the <tt>List</tt> interface
with additional "legacy methods."
<li>
<a
href="../../api/java/util/Hashtable.html"><strong>Hashtable</strong></a>
- Synchronized hash table implementation of the <tt>Map</tt> interface
that does not allow <tt>null</tt> keys or values, with additional
&quot;legacy methods.&quot;
</ul>

<li><strong>Special Purpose Implementations</strong>
<ul>
<li>
<strong><a
href="../../api/java/util/WeakHashMap.html">WeakHashMap</a></strong> -
An implementation of the <tt>Map</tt> interface that stores only <a
href="../../api/java/lang/ref/WeakReference.html"><i>weak
references</i></a> to its keys.  Storing only weak references allows
key-value pairs to be garbage-collected when the key is no longer
referenced outside of the <tt>WeakHashMap</tt>.  This class provides
the easiest way to harness the power of weak references.  It is useful
for implementing "registry-like" data structures, where the utility of
an entry vanishes when its key is no longer reachable by any thread.

<li><strong><a
href="../../api/java/util/IdentityHashMap.html">IdentityHashMap</a></strong> 
- Identity-based Map implementation based on a hash table. This class is useful
for topology-preserving object graph transformations (such as serialization or
deep-copying).  To perform such transformations, you need to maintain an
identity-based "node table" that keeps track of which objects have already
been seen. Identity-based maps are also used to maintain
object-to-meta-information mappings in dynamic debuggers and similar systems.
Finally, identity-based maps are useful in thwarting "spoof attacks" resulting
from intentionally perverse equals methods.  (<tt>IdentityHashMap</tt> never
invokes the equals method on its keys.)  An added benefit of this
implementation is that it is fast. 

<li><strong><a
href="../../api/java/util/concurrent/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a></strong>
- a <tt>List</tt> implementation backed by an copy-on-write array.  All
mutative operations (such as <tt>add</tt>, <tt>set</tt>, and <tt>remove</tt>)
are implemented by making a new copy of the array. No synchronization is
necessary, even during iteration, and iterators are guaranteed never to throw
<tt>ConcurrentModificationException</tt>. This implementation is well-suited
to maintaining event-handler lists (where change is infrequent, and traversal
is frequent and potentially time-consuming).

<li><strong><a
href="../../api/java/util/concurrent/CopyOnWriteArraySet.html">CopyOnWriteArraySet</a></strong>
- A <tt>Set</tt> implementation backed by a copy-on-write array.  This
implementation is similar in nature to <tt>CopyOnWriteArrayList</tt>.  Unlike
most <tt>Set</tt> implementations, the <tt>add</tt>, <tt>remove</tt>,
and <tt>contains</tt> methods require time proportional to the size of the
set.  This implementation is well-suited to maintaining event-handler lists
that must prevent duplicates.

<li><strong><a
href="../../api/java/util/EnumSet.html">EnumSet</a></strong>
- a high-performance <tt>Set</tt> implementation backed by a bit-vector.  All
elements of each <tt>EnumSet</tt> instance must be elements of a single enum
type.

<li><strong><a
href="../../api/java/util/EnumMap.html">EnumMap</a></strong>
- a high-performance <tt>Map</tt> implementation backed by an array.  All
keys in each <tt>EnumMap</tt> instance must be elements of a single enum
type.
</ul>

<li><strong>Concurrent Implementations</strong> - These implementations are
part of the package <tt>java.util.concurrent</tt>.
<ul>
<li><strong><a
href="../../api/java/util/concurrent/ConcurrentLinkedQueue.html">ConcurrentLinkedQueue</a></strong>
- An unbounded FIFO (first-in first-out) queue based on linked nodes.

<li><a href="../../api/java/util/concurrent/LinkedBlockingQueue.html"><strong>LinkedBlockingQueue</strong></a>
 - An optionally bounded FIFO blocking queue backed by linked nodes.

<li><a href="../../api/java/util/concurrent/ArrayBlockingQueue.html"><strong>ArrayBlockingQueue</strong></a>
 - A bounded FIFO blocking queue backed by an array.

<li><a href="../../api/java/util/concurrent/PriorityBlockingQueue.html"><strong>PriorityBlockingQueue</strong></a>
 - An unbounded blocking priority queue backed by a priority heap.

<li><a href="../../api/java/util/concurrent/DelayQueue.html"><strong>DelayQueue</strong></a>
 - A time-based scheduling queue backed by a priority heap.

<li><a href="../../api/java/util/concurrent/SynchronousQueue.html"><strong>SynchronousQueue</strong></a>
 - A simple rendezvous mechanism utilizing the <tt>BlockingQueue</tt> interface.
<li><a href="../../api/java/util/concurrent/ConcurrentHashMap.html"><strong>ConcurrentHashMap</strong></a>
- A highly concurrent, high-performance <tt>ConcurrentMap</tt> implementation based on a hash table.  This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates.  It is intended as a drop-in replacement for <tt><a href="../../api/java/util/Hashtable.html">Hashtable</a></tt>: in addition to implementing <tt>ConcurrentMap</tt>, it supports all of the "legacy" methods peculiar to <tt>Hashtable</tt>.
</ul>

<li>
<strong>Abstract Implementations</strong> - Skeletal implementations of
the collection interfaces to facilitate custom implementations.
<ul>
<li>
<a href="../../api/java/util/AbstractCollection.html"><strong>AbstractCollection</strong></a>
- Skeletal <tt>Collection</tt> implementation that is neither a set nor a
list (such as a "bag" or multiset).
<li>
<a href="../../api/java/util/AbstractSet.html"><strong>AbstractSet</strong></a>
- Skeletal <tt>Set</tt> implementation.
<li>
<a href="../../api/java/util/AbstractList.html"><strong>AbstractList</strong></a>
- Skeletal <tt>List</tt> implementation backed by a random-access data store
(such as an array).
<li>
<a href="../../api/java/util/AbstractSequentialList.html"><strong>AbstractSequentialList</strong></a>
- Skeletal <tt>List</tt> implementation backed by a sequential-access data store
(such as a linked list).
<li><a
href="../../api/java/util/AbstractQueue.html"><strong>AbstractQueue</strong></a> - Skeletal <tt>Queue</tt> implementation.
<li>
<a href="../../api/java/util/AbstractMap.html"><strong>AbstractMap</strong></a>
- Skeletal <tt>Map</tt> implementation.
</ul>

<li><strong>Algorithms</strong>
<ul>
<li><strong> <a href="../../api/java/util/Collections.html#sort(java.util.List)">
sort(List)</a></strong> - Sorts a list using a merge sort
algorithm, which provides average-case performance comparable to a
high-quality quicksort, guaranteed O(n*log n) performance (unlike quicksort),
and <em>stability</em> (unlike quicksort).  (A stable sort is one that does
not reorder equal elements.)

<li><strong> <a
href="../../api/java/util/Collections.html#binarySearch(java.util.List, T)"> binarySearch(List, Object)</a></strong> - Searches
for an element in an ordered list using the binary search algorithm.

<li><strong><a
href="../../api/java/util/Collections.html#reverse(java.util.List)">reverse(List)</a></strong>
- Reverses the order of the elements in the a list.

<li><strong><a
href="../../api/java/util/Collections.html#shuffle(java.util.List)">shuffle(List)</a></strong>
- Randomly permutes the elements in a list.

<li><strong><a
href="../../api/java/util/Collections.html#fill(java.util.List, T)">fill(List, Object)</a></strong> - Overwrites every
element in a list with the specified value.

<li><strong><a
href="../../api/java/util/Collections.html#copy(java.util.List, java.util.List)">copy(List dest, List src)</a></strong> - Copies the
source list into the destination list.

<li><strong> <a
href="../../api/java/util/Collections.html#min(java.util.Collection)">
min(Collection)</a></strong> - Returns the minimum element in a
collection.

<li><strong> <a
href="../../api/java/util/Collections.html#max(java.util.Collection)">
max(Collection)</a></strong> - Returns the maximum element in a
collection.

<li><strong><a href="../../api/java/util/Collections.html#rotate(java.util.List, int)">rotate(List list, int distance)</a></strong> - Rotates all of the elements
in the list by the specified distance.

<li><strong><a
href="../../api/java/util/Collections.html#replaceAll(java.util.List, T, T)">replaceAll(List list, Object oldVal,
Object newVal)</a></strong> - Replaces all occurrences of one specified value with another.

<li><strong><a
href="../../api/java/util/Collections.html#indexOfSubList(java.util.List, java.util.List)">indexOfSubList(List source, List target)</a></strong> - Returns the index of the first sublist of source that is equal to
target.

<li><strong><a
href="../../api/java/util/Collections.html#lastIndexOfSubList(java.util.List, java.util.List)">lastIndexOfSubList(List source, List target)</a></strong> -
Returns the index of the last sublist of source that is equal to
target.

<li><strong><a href="../../api/java/util/Collections.html#swap(java.util.List, int, int)">swap(List, int, int)</a></strong> - Swaps the elements at
the specified positions in the specified list.

<li><strong><a
href="../../api/java/util/Collections.html#frequency(java.util.Collection,
 java.lang.Object)">frequency(Collection, Object)</a></strong>
 - Counts the number of times the specified element occurs in the specified
collection.

<li><strong><a
href="../../api/java/util/Collections.html#disjoint(java.util.Collection, java.util.Collection)">disjoint(Collection, Collection)</a></strong> 
- Determines whether two collections are disjoint, in other
words, whether they contain no elements in common.

<li><strong><a
href="../../api/java/util/Collections.html#addAll(java.util.Collection, T...)">addAll(Collection&lt;? super T&gt;, T...)</a></strong> - 
Adds all of the elements in the specified array to the specified collection.
</ul>

<li><strong>Infrastructure</strong>
<ul>
<li><strong>Iterators</strong> - Similar to the familiar
<a href="../../api/java/util/Enumeration.html">Enumeration</a> interface,
but more powerful, and with improved method names.
<ul>
<li>
<a
href="../../api/java/util/Iterator.html"><strong>Iterator</strong></a>
- In addition to the functionality of the <tt>Enumeration</tt>
interface, allows the user to remove elements from the backing
collection with well defined, useful semantics.
<li>
<a
href="../../api/java/util/ListIterator.html"><strong>ListIterator</strong></a>
- Iterator for use with lists.  In addition to the functionality of
the <tt>Iterator</tt> interface, supports bi-directional iteration,
element replacement, element insertion and index retrieval.
</ul>
<li><strong>Ordering</strong>
<ul>
<li>
<a
href="../../api/java/lang/Comparable.html"><strong>Comparable</strong></a>
- Imparts a <i>natural ordering</i> to classes that implement it.  The
natural ordering may be used to sort a list or maintain order in a
sorted set or map.  Many classes have been retrofitted to implement
this interface.
<li>
<a
href="../../api/java/util/Comparator.html"><strong>Comparator</strong></a>
- Represents an order relation, which may be used to sort a list or
maintain order in a sorted set or map.  Can override a type's natural
ordering, or order objects of a type that does not implement the
<tt>Comparable</tt> interface.
</ul>
<li><strong>Runtime Exceptions</strong>
<ul>
<li><a href="../../api/java/lang/UnsupportedOperationException.html">
<strong>UnsupportedOperationException</strong></a> - Thrown by
collections if an unsupported optional operation is called.  <li><a
href="../../api/java/util/ConcurrentModificationException.html">
<strong>ConcurrentModificationException</strong></a> - Thrown by
iterators and list iterators if the backing collection is modified
unexpectedly while the iteration is in progress.  Also thrown by
<i>sublist</i> views of lists if the backing list is modified
unexpectedly.
</ul>

<li><strong>Performance</strong>
<ul>
<li>
<strong><a href="../../api/java/util/RandomAccess.html">RandomAccess</a></strong>
 - Marker interface that allows <tt>List</tt> implementations to indicate that
they support fast (generally constant time) random access.  This allows
generic algorithms to alter their behavior to provide good performance when
applied to either random or sequential access lists. 
</ul>
</ul>

<li><strong>Array Utilities</strong>
<ul>
<li><a href="../../api/java/util/Arrays.html"><strong>Arrays</strong></a>
- Contains static methods to sort, search, compare, hash, convert to
<tt>String</tt>, and fill arrays of primitives and Objects.
</ul>
</ul>

<!-- Body text ends here -->
<!-- ============================================================== -->

<HR SIZE=3 NOSHADE>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>

<TD>
<P><FONT SIZE="-2">
   <A HREF="../../relnotes/SMICopyright.html">Copyright &#169;</A> 1995-2004
   <A HREF="http://www.sun.com/">Sun Microsystems, Inc.</A>
    All Rights Reserved.</FONT></P>
   <br>
   <br>

   <FONT SIZE="-1">
   Please send comments to: <a href="mailto:collections-comments@java.sun.com">collections-comments@java.sun.com</a> 
   </FONT>
</TD>

<TD ALIGN=RIGHT>
   <IMG SRC="../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30>
   <BR>
   <FONT SIZE="+1">
   <i>Java Software</i>
   </FONT>
</TD>

</TR>
</TABLE>

</body>
</html>
