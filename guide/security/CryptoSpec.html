<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>

<TITLE>          Java Cryptography Architecture</TITLE>

<META NAME="AUTHOR" CONTENT="br">
<META NAME="OPERATOR" CONTENT="br">
</HEAD>

<BODY BGCOLOR="white">
<HR>

<center>
<H1>Java<font size=-1><sup>TM</sup></font> Cryptography Architecture </H1>

<H1>API Specification &amp; Reference</H1>
<br>

<H3><I>Last Modified: 25 July 2004</I></H3>

</center>

<HR>

<p>

<DL>
  <DT><B><FONT SIZE="+2"><A HREF="#Introduction">Introduction</A></FONT></B>
  <DD><A HREF="#Design"><B>Design Principles</B></A>
  <DD><A HREF="#Architecture"><B>Architecture</B></A>
  <DD><A HREF="#Concepts"><B>Concepts</B></A>
  <DD>&nbsp;
  <DT><B><FONT SIZE="+2"><A HREF="#WhatsNew">What's New in JCE 
      in the Java 2 Platform Standard Edition 5</A></FONT></B>
  <DD>&nbsp;
  <DT><A HREF="#CoreClasses"><B><FONT SIZE="+2">Core Classes and
  Interfaces</FONT></B></A>
  <DD><A HREF="#Provider"><B>The <CODE>Provider</CODE> Class</B></A>
  <DL>
    <DD><A HREF="#ProviderImplReq"><B>How Provider Implementations
    are Requested and Supplied</B></A>
    <DD><A HREF="#ProviderInstalling"><B>Installing Providers</B></A>
  </DL>
  <DD><A HREF="#Security"><B>The <CODE>Security</CODE> Class</B></A>
  <DD><A HREF="#MessageDigest"><B>The <CODE>MessageDigest</CODE>
  Class</B></A>
  <DD><A HREF="#Signature"><B>The <CODE>Signature</CODE> Class</B></A><!--SELECTION--><!--/SELECTION-->
  <DD><A HREF="#AlgParms"><B>Algorithm Parameters Classes</B></A>
  <UL>
    <DL>
      <DT><A HREF="#AlgSpec"><B>Algorithm Parameter Specification Interfaces
      and Classes</B></A>
      <DD><A HREF="#AlgorithmParameterSpec"><B>The <CODE>AlgorithmParameterSpec</CODE>
      Interface</B></A>
      <DD><A HREF="#DSAParameterSpec"><B>The <CODE>DSAParameterSpec</CODE>
      Class</B></A>
      <DT><A HREF="#AlgorithmParameters"><B>The <CODE>AlgorithmParameters</CODE>
      Class</B></A>
      <DT><A HREF="#AlgorithmParameterGenerator"><B>The <CODE>AlgorithmParameterGenerator</CODE>
      Class</B></A>
      <DT><A HREF="#Key"><B><CODE>Key</CODE> Interfaces</B></A>
      <DT><A HREF="#KeySpecs"><B><CODE>Key</CODE> Specification Interfaces
      and Classes</B></A>
      <DD><A HREF="#KeySpec"><B>The <CODE>KeySpec</CODE> Interface</B></A>
      <DL>
        <DD><A HREF="#DSAPrivateKeySpec"><B>The <CODE>DSAPrivateKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#DSAPublicKeySpec"><B>The <CODE>DSAPublicKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#RSAPrivateKeySpec"><B>The <CODE>RSAPrivateKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#RSAPrivateCrtKeySpec"><B>The <CODE>RSAPrivateCrtKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#RSAMultiPrimePrivateCrtKeySpec"><B>The <CODE>RSAMultiPrimePrivateCrtKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#RSAPublicKeySpec"><B>The <CODE>RSAPublicKeySpec</CODE>
        Class</B></A>
        <DD><A HREF="#EncodedKeySpec"><B>The <CODE>EncodedKeySpec</CODE>
        Class</B></A>
        <DL>
          <DD><A HREF="#PKCS8EncodedKeySpec"><B>The <CODE>PKCS8EncodedKeySpec</CODE>
          Class</B></A>
          <DD><A HREF="#X509EncodedKeySpec"><B>The <CODE>X509EncodedKeySpec</CODE>
          Class</B></A>
        </DL>
      </DL>
      <DT><A HREF="#KeyFactory"><B>The <CODE>KeyFactory</CODE> Class</B></A>
      <DT><A HREF="#CertificateFactory"><B>The <CODE>CertificateFactory</CODE>
      Class</B></A>
      <DT><A HREF="#KeyPair"><B>The <CODE>KeyPair</CODE> Class</B></A>
      <DT><A HREF="#KPG"><B>The <CODE>KeyPairGenerator</CODE> Class</B></A>
      <DT><A HREF="#KeyManagement"><B>Key Management</B></A>
      <DD><A HREF="#KeystoreLocation"><B>Keystore Location</B></A>
      <DD><A HREF="#KeystoreImplementation"><B>Keystore Implementation</B></A>
      <DD><A HREF="#KeyStore"><B>The <CODE>KeyStore</CODE> Class</B></A>
      <DT><A HREF="#SecureRandom"><B>The <CODE>SecureRandom</CODE>
      Class</B></A>
      <DT><A HREF="#CipherClass"><B>The <CODE>Cipher</CODE> Class</B></A>
      <DT><A HREF="#CipherStream"><B>The <CODE>CipherStream</CODE> Classes</B></A>
      <DD><A HREF="#CipherInput"><B>The <CODE>CipherInputStream</CODE> Class</B></A>
      <DD><A HREF="#CipherOutput"><B>The <CODE>CipherOutputStream</CODE> Class</B></A>
      <DT><A HREF="#KeyGenerator"><B>The <CODE>KeyGenerator</CODE> Class</B></A>
      <DT><A HREF="#SecretFactory"><B>The <CODE>SecretKeyFactory</CODE> Class</B></A>
      <DT><A HREF="#SealedObject"><B>The <CODE>SealedObject</CODE> Class</B></A>
      <DT><A HREF="#KeyAgreement"><B>The <CODE>KeyAgreement</CODE> Class</B></A>
      <DT><A HREF="#Mac"><B>The <CODE>Mac</CODE> Class</B></A>
    <BR>
    </DL>
  </UL>
</DL>

<DL>
  <DT><a href="#ExemptApps"><font size="+2"><b>How to Make Applications 
  "Exempt" from Cryptographic Restrictions</b></font></a> <br>
</DL>

<DL>
  <DT><A HREF="#Examples"><B><FONT SIZE="+2">Code Examples</FONT></B></A>
    <DD><A HREF="#MDEx"><B>Computing a <CODE>MessageDigest</CODE>
    Object</B></A>
    <DD><A HREF="#KPGEx"><B>Generating a Pair of Keys</B></A>
    <DD><A HREF="#SigEx"><B>Generating and Verifying a Signature
    Using Generated Keys</B></A>
    <DD><A HREF="#KeyFactoryEx"><B>Generating/Verifying Signatures
    Using <CODE>Key</CODE> Specifications and <CODE>KeyFactory</CODE></B></A>
    <DD><A HREF="#Equal"><B>Determining If Two Keys Are Equal</B></A>
    <DD><A HREF="#ReadCert"><B>Reading Base64-Encoded Certificates</B></A>
    <DD><A HREF="#ParseCert"><B>Parsing a Certificate Reply</B></A>
    <dd><a href="#SimpleEncrEx"><b>Using Encryption</b></a> </dd>
    <dd><a href="#PBEEx"><b>Using Password-Based Encryption</b></a> </dd>
    <dd><a href="#KeyAgreeEx"><b>Using Key Agreement</b></a> </dd>
</DL>

<DL>
<DT><A HREF="#AppA"><B><FONT SIZE="+2">Appendix A: Standard Names
  </FONT></B></A><BR>
<BR>
  <DT><A HREF="#AppB"><B><FONT SIZE="+2">Appendix B: Algorithms</FONT></B></A><BR>
<BR>
  <dt><a href="#AppC"><font size="+2"><b>Appendix C: SunJCE Keysize
Restrictions</b></font></a> <br><BR>
  <dt><a href="#AppD"><font size="+2"><b>Appendix D: Jurisdiction
Policy File Format</b></font></a> <br><BR>
  <dt><a href="#AppE"><font size="+2"><b>Appendix E: Maximum Key Sizes
Allowed by "Strong" Jurisdiction Policy Files</b></font></a> <br><BR>
  <dt><a href="#AppF"><font size="+2"><b>Appendix F: Sample Programs</b></font></a>
      <dd><a href="#DH2Ex"><b>Diffie-Hellman Key Exchange between 2
Parties</b></a> </dd>
      <dd><a href="#DH3Ex"><b>Diffie-Hellman Key Exchange between 3
Parties</b></a> </dd>
      <dd><a href="#BlowKeyEx"><b>Blowfish Example</b></a> </dd>
      <dd><a href="#HmacEx"><b>HMAC-MD5 Example</b></a> </dd>
    </dl>



<HR>

<H1><a name="Introduction">Introduction</a></H1>

<blockquote>

<P>
The Security API is a core API of the Java programming language, 
built around the
<code>java.security</code> package (and its subpackages). 
This API is designed to allow developers to incorporate both 
low-level and high-level security functionality into their programs. 

<p>The first release of Security API in JDK 1.1 introduced the
"Java Cryptography Architecture" (JCA), a framework for
accessing and developing cryptographic functionality for the Java platform.
In JDK 1.1, the JCA included APIs for digital signatures
and message digests.

<p>In subsequent releases, the Java 2 SDK significantly extended 
the Java Cryptography Architecture, as described in this document. 
It also upgraded the certificate management 
infrastructure to support X.509 v3 certificates, and introduced a new 
Java Security Architecture for fine-grain, highly configurable, flexible, 
and extensible access control.

<p>The Java Cryptography Architecture encompasses the parts of the 
Java 2 SDK Security API related to cryptography, as well
as a set of conventions and specifications provided in this document.
It includes a <a href = "#ProviderArch">"provider"</a> architecture 
that allows for multiple and interoperable cryptography implementations.

<p>The Java<sup><font size="-2">TM</font></sup> Cryptography
Extension (JCE) provides a framework and implementations for
encryption, key generation and key agreement, and Message
Authentication Code (MAC) algorithms. Support for encryption includes
symmetric, asymmetric, block, and stream ciphers. The software also
supports secure streams and sealed objects. </p>
  <p>JCE was previously an optional package (extension) to the Java<sup><font
 size="-2">TM</font></sup> 2 SDK, Standard Edition (Java 2 SDK),
versions 1.2.x and 1.3.x. JCE has been integrated into the Java 2 SDK
since the 1.4 release. </p>

  <p>The JCE API covers: </p>
  <ul>
    <li>Symmetric bulk encryption, such as DES, RC2, and IDEA
      <p></p>
    </li>
    <li>Symmetric stream encryption, such as RC4
      <p></p>
    </li>
    <li>Asymmetric encryption, such as RSA
      <p></p>
    </li>
    <li>Password-based encryption (PBE)
      <p></p>
    </li>
    <li>Key Agreement
      <p></p>
    </li>
    <li>Message Authentication Codes (MAC) </li>
  </ul>
  <p>J2SE 5 comes standard with a JCE provider
named "<code>SunJCE</code>", which comes pre-installed and registered
and which supplies the following cryptographic services: </p>
  <ul>
    <li>An implementation of the DES (FIPS PUB 46-1), Triple DES, and
Blowfish encryption algorithms in the Electronic Code Book (ECB),
Cipher Block Chaining (CBC), Cipher Feedback (CFB), Output Feedback
(OFB), and Propagating Cipher Block Chaining (PCBC) modes. (Note:
Throughout this document, the terms "Triple DES" and "DES-EDE" will be
used interchangeably.)
      <p></p>
    </li>
    <li>Key generators for generating keys suitable for the DES, Triple
DES, Blowfish, HMAC-MD5, and HMAC-SHA1 algorithms.
      <p></p>
    </li>
    <li>An implementation of the MD5 with DES-CBC password-based
encryption (PBE) algorithm defined in PKCS #5.
      <p></p>
    </li>
    <li>"Secret-key factories" providing bi-directional conversions
between opaque DES, Triple DES and PBE key objects and transparent
representations of their underlying key material.
      <p></p>
    </li>
    <li>An implementation of the Diffie-Hellman key agreement algorithm
between two or more parties.
      <p></p>
    </li>
    <li>A Diffie-Hellman key pair generator for generating a pair of
public and private values suitable for the Diffie-Hellman algorithm.
      <p></p>
    </li>
    <li>A Diffie-Hellman algorithm parameter generator.
      <p></p>
    </li>
    <li>A Diffie-Hellman "key factory" providing bi-directional
conversions between opaque Diffie-Hellman key objects and transparent
representations of their underlying key material.
      <p></p>
    </li>
    <li>Algorithm parameter managers for Diffie-Hellman, DES, Triple
DES, Blowfish, and PBE parameters.
      <p></p>
    </li>
    <li>An implementation of the HMAC-MD5 and HMAC-SHA1 keyed-hashing
algorithms defined in RFC 2104.
      <p></p>
    </li>
    <li>An implementation of the padding scheme described in PKCS #5.
      <p></p>
    </li>
    <li>A keystore implementation for the proprietary keystore type
named "JCEKS". </li>
  </ul>
  <h3><a name="Terminology">A Note on Terminology</a></h3>
  <blockquote>
    <p>The JCE within the JDK includes two software
components: </p>
    <ul>
      <li>the framework that defines and supports cryptographic
services that providers can supply implementations for. This framework
includes everything in the <code>javax.crypto</code> package.
        <p></p>
      </li>
      <li>a provider named "SunJCE" </li>
    </ul>
Throughout this document, the term "JCE" by itself refers to the JCE
framework in J2SE 5. Whenever the JCE provider supplied
with J2SE 5 is mentioned, it will be referred to
explicitly as the "SunJCE" provider. </blockquote>

<BLOCKQUOTE>
<HR>
<B>Note:</B> The most recent version of this JCA specification can be found
online at: 
<a href = "CryptoSpec.html">
http://java.sun.com/j2se/1.5.0/docs/guide/security/CryptoSpec.html</a>.
<HR>
</BLOCKQUOTE>

</blockquote>


<H2><a name="Design">Design Principles</a></H2>

<blockquote>

<P>
The Java Cryptography Architecture (JCA) was designed around these 
principles:
<UL>
<LI>implementation independence and interoperability<p>
<LI>algorithm independence and extensibility
</UL>

<P>
Implementation independence and algorithm independence are complementary; 
you can use cryptographic services, 
such as digital signatures and message digests,
without worrying about the implementation details or even the algorithms
that form the basis for these concepts. When complete algorithm-independence
is not possible, the JCA provides standardized, 
algorithm-specific APIs. When implementation-independence is not
desirable, the JCA lets developers indicate a specific implementation.

<P>
Algorithm independence is achieved by defining types of cryptographic
"engines" (services), and defining classes that provide the 
functionality of these cryptographic engines.  These classes are called 
<I>engine classes</I>, and examples are the 
<a href="#MessageDigest"><code>MessageDigest</code></a>, 
<a href="#Signature"><code>Signature</code></a>, 
<a href="#KeyFactory"><code>KeyFactory</code></a>, and 
<a href="#KPG"><code>KeyPairGenerator</code></a> classes.
<P>
Implementation independence is achieved using a "provider"-based
architecture. The term <a href = "#ProviderArch">Cryptographic Service 
Provider</a> (used interchangeably with "provider" in this document) 
refers to a package or set of packages that implement one or more
cryptographic services, such as digital signature algorithms,
message digest algorithms, and key conversion services.
A program may simply request a particular type of object
(such as a <code>Signature</code> object) implementing a particular
service (such as the DSA signature algorithm) and get an 
implementation from one of the installed providers.
If desired, a program may instead request an implementation from 
a specific provider. Providers may be updated transparently to the 
application, for example when faster or more secure versions are
available.

<P>
Implementation interoperability means that various implementations
can work with each other, use each other's keys, or verify each
other's signatures. This would mean, for example, that for the
same algorithms, a key generated by one provider would be
usable by another, and a signature generated
by one provider would be verifiable by another.

<P>
Algorithm extensibility means that new algorithms that fit in
one of the supported engine classes can be added easily.

</blockquote>


<H2><a name="Architecture">Architecture</a></H2>

<blockquote>


<H4><a name="ProviderArch">Cryptographic Service Providers</a></H4>

<p>The Java Cryptography Architecture introduced the notion of a 
<em>Cryptographic Service Provider</em> 
(used interchangeably with "provider" in this document). This term refers to
a package (or a set of packages) that supplies 
a concrete implementation of a subset of the cryptography aspects of
the Security API.  

<p>For example, in JDK 1.1 a provider could contain an implementation 
of one or more digital signature
algorithms, message digest algorithms, and key generation
algorithms. Java 2 SDK adds five additional types of services:
key factories, keystore creation and management, 
algorithm parameter management,
algorithm parameter generation, and certificate factories.
It also enables a provider to
supply a random number generation (RNG) algorithm. Previously, 
RNGs were not provider-based; a particular algorithm was
hard-coded in the JDK.

<p>As previously noted, a program may simply request a particular type of 
object (such as a <code>Signature</code> object) for a particular service (such as the 
DSA signature algorithm) and get an implementation from one of 
the installed providers. Alternatively, the program can request
the objects from a specific provider. (Each provider has a name used to refer to it.)

<A NAME="j2sdkenginelist"></A>
<p>Sun's version of the Java runtime environment comes
standard with a default provider, named <code>SUN</code>.
Other Java runtime environments may not necessarily supply the
<code>SUN</code> provider. The <code>SUN</code> provider package includes:

<ul>

<li>An implementation of the Digital Signature Algorithm (DSA), described
in NIST FIPS 186.<p>

<li>An implementation of the MD5 (RFC 1321) and SHA-1 (NIST FIPS 180-1)
message digest algorithms.<p>

<li>A DSA key pair generator for generating a pair of public and private
keys suitable for the DSA algorithm.<p>

<li>A DSA algorithm parameter generator.<p>

<li>A DSA algorithm parameter manager.<p>

<li>A DSA key factory providing bi-directional conversions between
(opaque) DSA private and public key objects and their underlying key
material.<p>

<li>An implementation of the proprietary "SHA1PRNG" 
pseudo-random number generation algorithm, following the recommendations
in the IEEE P1363 standard (Appendix G.7).<p>

<li>A certificate path builder and validator for PKIX, as defined in the 
Internet X.509 Public Key Infrastructure Certificate and CRL Profile</I> 
(available as a draft from <A HREF="http://www.ietf.org/">Internet Engineering Task 
Force</A> at the time of this writing.).<P>

<li>A certificate store implementation for retrieving certificates and CRLs 
from Collection and LDAP directories, using the PKIX LDAP V2 Schema 
(<A HREF="http://www.ietf.org/rfc/rfc2587.txt?number=2587">RFC 2587</A>).<P>
      
<li>A certificate factory for X.509 certificates and Certificate
Revocation Lists (CRLs).<p>

<li>A keystore implementation for the proprietary keystore
type named <code>JKS</code>.

</ul>

<p>Each SDK installation has one or more provider packages installed. 
New providers may be added statically or dynamically (see
the <a href = "#Provider">Provider</a> and 
<a href = "#Security">Security</a> classes). The 
Java Cryptography Architecture offers a 
set of APIs that allow users to query
which providers are installed and what services they support.
<P>
Clients may configure their runtime with different providers,
and specify a <i>preference order</i> for each of them. The preference
order is the order in which providers are searched for requested 
services when no specific provider is requested. 

<H4><a name="KeyManagement">Key Management</a></H4>

<P>
A database called a "keystore" can be used to 
manage a repository of keys and certificates. 
A keystore is available to
applications that need it for authentication or signing purposes.

<p>Applications can access a keystore via an implementation of the
<code>KeyStore</code> class, which is in the <code>java.security</code> package.
A default <code>KeyStore</code> implementation is provided by Sun Microsystems.
It implements the keystore as a file, using a proprietary 
keystore type (format) named "JKS".

<p>Applications can choose different types of keystore implementations
from different providers, using the <code>getInstance</code> factory method supplied
in the <code>KeyStore</code> class.

<p>See the <a href = "#KeyManagement">Key Management</a> section for more 
information.



</blockquote>


<H2><a name="Concepts">Concepts</a></H2>

<blockquote>

<P>
This section covers the major concepts introduced in the API.


<H4><a name="Engine">Engine Classes and Algorithms</a></H4>

<P>
An <I>engine class</I> defines a cryptographic service
in an abstract fashion (without a concrete implementation).

<p>A cryptographic service is always 
associated with a particular algorithm or type,
and it either provides cryptographic operations 
(like those for digital
signatures or message digests), generates or supplies the
cryptographic material (keys or parameters) 
required for cryptographic 
operations, or generates data objects
(keystores or certificates) that encapsulate cryptographic
keys (which can be used in a cryptographic operation)
in a secure fashion. For example, two of the engine classes are the <code>Signature</code>
and <code>KeyFactory</code> classes. The <code>Signature</code> 
class provides access to the functionality of a
digital signature algorithm.
A DSA <code>KeyFactory</code> supplies a DSA private
or public key (from its encoding or transparent specification)
in a format usable by the <code>initSign</code> or <code>initVerify</code> methods,
respectively, of a DSA <code>Signature</code> object.

<p>The Java Cryptography Architecture encompasses the classes of the
Java 2 SDK Security package related to cryptography, including the
engine classes. Users of the API request and use 
instances of the engine classes to carry out corresponding operations. 
The following engine classes are defined in Java 2 SDK:

<ul>

<li><a href = "#MessageDigest"><code>MessageDigest</code></a>: used 
to calculate the message digest (hash) of specified data.<p>

<li><a href = "#Signature"><code>Signature</code></a>: used to sign data
and verify digital signatures.<p>

<li><a href = "#KPG"><code>KeyPairGenerator</code></a>: used to generate a pair of 
public and private keys suitable for a specified algorithm.<p>

<li><a href = "#KeyFactory"><code>KeyFactory</code></a>: used to
convert opaque cryptographic keys of type <a href = "#Key"><code>Key</code></a> 
into <i>key specifications</i> (transparent representations of the underlying
key material), and vice versa.<p>

<li><a href = "#CertificateFactory"><code>CertificateFactory</code></a>: used to
create public key certificates and Certificate Revocation Lists (CRLs).<p>

<li><a href = "#KeyStore"><code>KeyStore</code></a>: used to create and manage a 
<i>keystore</i>.A keystore is a database of keys. Private keys in a keystore 
have a certificate chain associated with them, which authenticates 
the corresponding public key.
A keystore also contains certificates from trusted entities.
<p>

<li><a href = "#AlgorithmParameters"><code>AlgorithmParameters</code></a>: used 
to manage the parameters for a particular algorithm, including
parameter encoding and decoding.<p>

<li><a href = "#AlgorithmParameterGenerator"><code>AlgorithmParameterGenerator</code></a>: 
 used to generate a set of parameters suitable for a
specified algorithm.<p>

<li><a href = "#SecureRandom"><code>SecureRandom</code></a>: used to generate random
or pseudo-random numbers.

</ul>

In the 1.4 release of the Java 2 SDK, the following new engines were  added:
<UL>
<li><A HREF="../../api/java/security/cert/CertPathBuilder.html"><code>CertPathBuilder</code></A>: 
used to build certificate chains (also known as certification paths).<P>

<li><A HREF="../../api/java/security/cert/CertPathValidator.html"><code>CertPathValidator</code></A>: 
used to validate certificate chains.<P>

<li><A HREF="../../api/java/security/cert/CertStore.html"><code>CertStore</code></A>: 
used to retrieve <code>Certificate</code>s and <code>CRL</code>s from a repository. 
</UL>

<blockquote>
<hr>
<B>Note:</B> A <I>generator</I> creates objects with brand-new contents, whereas 
a <i>factory</i> creates objects from existing material (for example, an 
encoding).
<hr>
</blockquote>

An engine class provides the interface to the functionality of a
specific type of cryptographic service (independent
of a particular cryptographic algorithm). 
It defines Application Programming Interface (API)
methods that allow applications to access the specific type
of cryptographic service it provides. The actual implementations 
(from one or more providers) are those for specific
algorithms.  The <code>Signature</code> engine
class, for example, provides access to the functionality of a
digital signature algorithm. The actual implementation supplied
in a <code>SignatureSpi</code>  subclass would be that 
for a specific kind of signature
algorithm, such as SHA-1 with DSA, SHA-1 with RSA, or MD5 with RSA. 

<p>
The application interfaces supplied by an engine class are
implemented in terms of a Service Provider Interface (SPI).
That is, for each engine class, there is a corresponding
abstract SPI class, which defines the SPI methods that 
cryptographic service providers must implement.

<p>An instance of an engine class, the API object, encapsulates (as a
private field) an instance of the corresponding SPI class, the SPI
object.  All API methods of an API object are declared final and
their implementations invoke the corresponding SPI methods of the
encapsulated SPI object. An instance of an engine class (and of its
corresponding SPI class) is created by a call to
the <code>getInstance</code> factory method of the engine class.

<p>The name of each SPI class is the same as that of the corresponding 
engine class, followed by <code>Spi</code>. For example,
the SPI class corresponding to the <code>Signature</code> engine class is the
<code>SignatureSpi</code>  class.

<p>
Each SPI class is abstract. To supply the implementation of a 
particular type of service, for a specific algorithm,
a provider must subclass the corresponding SPI class and provide
implementations for all the abstract methods.

<p>
Another example of an engine class is the <code>MessageDigest</code> class, which
provides access to a message digest algorithm. Its implementations, 
in <code>MessageDigestSpi</code> subclasses, may be those of various
message digest algorithms such as SHA-1, MD5, or MD2.

<p>
As a final example, the <code>KeyFactory</code> engine class supports the conversion 
from opaque keys to transparent key specifications, and vice versa.
(See the <a href = "#KeySpecs">Key Specification Interfaces and Classes</a>
section.) 
The <code>KeyFactorySpi</code> subclass supplies an actual implementation  
for a specific type of keys, for example, DSA public and private keys.


<H4>Implementations and Providers</H4>

<P>
Implementations for various cryptographic services are provided by JCA
<a href = "#ProviderArch">Cryptographic Service Providers.</a> Cryptographic 
service providers 
are essentially packages that supply one or more cryptographic service
implementations. 
The <I>Engine Classes and Algorithms</I> section includes a 
<A HREF="#j2sdkenginelist">list of implemenations supplied by SUN</A>, 
the Java 2 SDK's default provider.

<p>Other providers may define their own implementations of
these services or of other services,
such as one of the RSA-based signature algorithms or the 
MD2 message digest algorithm.

<H4>Factory Methods to Obtain Implementation Instances</H4>

<P>

For each engine class in the API, a particular implementation is 
requested and instantiated
by calling a <i>factory method</i> on the engine class. 
A factory method
is a static method that returns an instance of a class.

<p>The basic mechanism for obtaining an appropriate <code>Signature</code> object,
for example,
is as follows: A user requests such an object by calling the 
<code>getInstance</code> method in the <code>Signature</code> class, specifying 
the name of a 
signature algorithm (such as "SHA1withDSA"), and, optionally, the name
of the provider or the <code>Provider</code> class. The <code>getInstance</code> method finds an implementation
that satisfies the supplied algorithm and provider parameters. If no
provider is specified, <code>getInstance</code> searches the
registered providers, in preference order, for one with an 
implementation of the specified algorithm. See <a href=
"#Provider">The <code>Provider</code> Class</a> for more
information about registering providers.

<h4><a name="Concepts">Cryptographic Concepts</a></h4>
<blockquote>
  <p>This section provides a high-level description of the concepts
implemented by the API, and the exact meaning of the technical terms
used in the API specification. </p>
  <h4><a name="EncrDecr">Encryption and Decryption</a></h4>
  <p>Encryption is the process of taking data (called <i>cleartext</i>)
and a short string (a <i>key</i>), and producing data (<i>ciphertext</i>)
meaningless to a third-party who does not know the key. Decryption is
the inverse process: that of taking ciphertext and a short key string,
and producing cleartext. </p>
  <h4><a name="PBE">Password-Based Encryption</a></h4>
  <p>Password-Based Encryption (PBE) derives an encryption key from a
password. In order to make the task of getting from password to key
very time-consuming for an attacker, most PBE implementations will mix
in a random number, known as a <i>salt</i>, to create the key. </p>
  <h4><a name="Cipher">Cipher</a></h4>
  <p>Encryption and decryption are done using a cipher. A cipher is an
object capable of carrying out encryption and decryption according to
an encryption scheme (algorithm). </p>
  <h4><a name="KeyAgree">Key Agreement</a></h4>
  <p>Key agreement is a protocol by which 2 or more parties can
establish the same cryptographic keys, without having to exchange any
secret information. </p>
  <p> </p>
  <h4><a name="MAC">Message Authentication Code</a></h4>
  <p>A Message Authentication Code (MAC) provides a way to check the
integrity of information transmitted over or stored in an unreliable
medium, based on a secret key. Typically, message authentication codes
are used between two parties that share a secret key in order to
validate information transmitted between these parties. </p>
  <p>A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash
function, e.g., MD5 or SHA-1, in combination with a secret shared key.
HMAC is specified in RFC 2104. </p>
</blockquote>

</blockquote>

<h1><a name="WhatsNew">What's New in JCE in J2SE 5</a></h1>
<blockquote>
  <p>Here are the differences in JCE between v1.4 and J2SE 5: </p>
  <ul>
    <li><a href="#PKCSSupp"> Support for Additional Features of PKCS #11</a>
      <p></p>
    </li>
    <li><a href="#SolarisCrypto"> Integration with Solaris
Cryptographic Framework</a>
      <p></p>
    </li>
    <li><a href="#ECC-Support"> Support for ECC Algorithm</a>
      <p></p>
    </li>
    <li><a href="#ByteBufferSupp"> Added <code>ByteBuffer</code> API
Support to JCA/JCE</a>
      <p></p>
    </li>
    <li><a href="#RC2ParameterSpec"> Support for <code>RC2ParameterSpec</code></a>
      <p></p>
    </li>
    <li><a href="#RSA-OAEP"> Full support for XML Encryption RSA-OAEP
Algorithm</a>
      <p></p>
    </li>
    <li><a href="#EncryptedPrivateKeyInfo"> Simplified retrieval of <code>PKCS8EncodedKeySpec</code>
from <code>javax.crypto.EncryptedPrivateKeyInfo</code></a>
      <p></p>
    </li>
    <li><a href="#PBECiphers"> Support for "PBEWithSHA1AndDESede" and
"PBEWithSHA1AndRC2_40" Ciphers</a>
      <p></p>
    </li>
    <li><a href="#XMLEncryptionPadding"> Support for XML Encryption
Padding Algorithm in JCE Block Encryption Ciphers</a>
      <p></p>
    </li>
    <li><a href="#DynamicKeyLength"> Ability to Dynamically Determine
Maximum Allowable Key Length </a>
      <p></p>
    </li>
    <li><a href="#SupportRSAEncryption"> Support for RSA encryption to
SunJCE provider</a>
      <p></p>
    </li>
    <li><a href="#SupportRC2-ARCFOUR"> Support for RC2 and ARCFOUR
Ciphers to SunJCE provider</a>
      <p></p>
    </li>
    <li><a href="#SupportHMACSHA"> Support for HmacSHA256, HmacSHA384
and HmacSHA512</a>
      <p></p>
    </li>
  </ul>
  <h3><a name="PKCSSupp">Support for PKCS #11 Based Crypto Provider</a></h3>
  <blockquote>
In J2SE 5, a JCA/JCE provider, <code>SunPKCS11</code> that acts as a
generic gateway to the native PKCS#11 API has been implemented. PKCS#11
is the de-facto standard for crypto accelerators and also widely used
to access cryptographic smartcards. The administrator/user can
configure this provider to talk any PKCS#11 v2.x compliant token.
    <p>Here's an example of the configuration file <a
 href="../p11guide.html#Config">format</a>.
    </p>
  </blockquote>
  <h3><a name="SolarisCrypto">Integration with Solaris Cryptographic
Framework</a></h3>
  <blockquote>
    <p>On Solaris 10, the default Java security provider configuration
has been changed in J2SE 5 to include an instance of the <code>SunPKCS11</code>
provider that uses the Solaris Cryptographic Framework. It is the
provider with the highest precedence thereby allowing all existing
applications to take advantage of the improved performance on Solaris
10. There is no change in behavior on Solaris 8 and Solaris 9 systems.
    </p>
    <p> As a result of this change, many cryptographic operations will
execute several times as fast as before on all Solaris 10 systems. On
systems with cryptographic hardware acceleration, the performance
improvements may be two orders of magnitude.
    </p>
  </blockquote>
  <h3><a name="ECC-Support">Support for ECC Algorithm</a></h3>
  <blockquote>
Prior to J2SE 5, the JCA/JCE framework did not include support classes for
ECC-related
crypto algorithms. Users who wanted to use ECC had to depend on a 3rd
party library
that implemented ECC. However, this did not integrate well with
existing JCA/JCE framework.
    <p>Starting in J2SE 5, full support for ECC classes to facilitate
providers that support ECC
have been included.
    </p>
    <p> The following interfaces have been added: </p>
    <ul>
      <li><a href="../../api/java/security/spec/ECField.html">
java.security.spec.ECField</a> </li>
      <li><a href="../../api/java/security/interfaces/ECKey.html">
java.security.interfaces.ECKey</a> </li>
      <li><a
 href="../../api/java/security/interfaces/ECPublicKey.html">
java.security.interfaces.ECPublicKey</a> </li>
      <li><a
 href="../../api/java/security/interfaces/ECPrivateKey.html">
java.security.interfaces.ECPrivateKey</a> </li>
    </ul>
    <p> The following classes have been added: </p>
    <ul>
      <li><a href="../../api/java/security/spec/ECFieldF2m.html">
java.security.spec.ECFieldF2m</a> </li>
      <li><a href="../../api/java/security/spec/ECFieldFp.html">
java.security.spec.ECFieldFp</a> </li>
      <li><a
 href="../../api/java/security/spec/ECGenParameterSpec.html">
java.security.spec.ECGenParameterSpec</a> </li>
      <li><a href="../../api/java/security/spec/ECParameterSpec.html">
java.security.spec.ECParameterSpec</a> </li>
      <li><a href="../../api/java/security/spec/ECPoint.html">
java.security.spec.ECPoint</a> </li>
      <li><a
 href="../../api/java/security/spec/ECPrivateKeySpec.html">
java.security.spec.ECPrivateKeySpec</a> </li>
      <li><a href="../../api/java/security/spec/ECPublicKeySpec.html">
java.security.spec.ECPublicKeySpec</a> </li>
    </ul>
  </blockquote>
  <h3><a name="ByteBufferSupp">Added ByteBuffer API Support</a></h3>
  <blockquote>
Methods that take ByteBuffer arguments have been added to the JCE API
and SPI classes that are used to process bulk data. Providers can
override the engine* methods if they can process ByteBuffers more
efficiently than byte[].
    <p>The following JCE methods have been added to support
ByteBuffers:
    </p>
    <pre>    javax.crypto.Mac.update(ByteBuffer input)<br>    javax.crypto.MacSpi.engineUpdate(ByteBuffer input)<br>    javax.crypto.Cipher.update(ByteBuffer input, ByteBuffer output)<br>    javax.crypto.Cipher.doFinal(ByteBuffer input, ByteBuffer output)<br>    javax.crypto.CipherSpi.engineUpdate(ByteBuffer input, ByteBuffer output)<br>    javax.crypto.CipherSpi.engineDoFinal(ByteBuffer input, ByteBuffer output)<br></pre>
The following JCA methods have been added to support ByteBuffers:
    <pre>    java.security.MessageDigest.update(ByteBuffer input)<br>    java.security.Signature.update(ByteBuffer data)<br>    java.security.SignatureSpi.engineUpdate(ByteBuffer data)<br>    java.security.MessageDigestSpi.engineUpdate(ByteBuffer input)<br></pre>
  </blockquote>
  <h3><a name="RC2ParameterSpec">Support for RC2ParameterSpec</a></h3>
  <blockquote>
The RC2 algorithm implementation has been enhanced in J2SE 5 to support
effective key size
that is distinct from the length of the input key.
  </blockquote>
  <h3><a name="RSA-OAEP">Full support for XML Encryption RSA-OAEP
Algorithm</a></h3>
  <blockquote>
    <p> Prior to J2SE 5, JCE did not define any parameter class for
specifying the non-default values used in OAEP and PSS padding as
defined in PKCS#1 v2.1 and the RSA-OAEP Key Transport algorithm in the <a
 href="http://www.w3.org/TR/xmlenc-core/">W3C Recommendation for XML
Encryption</a>. Therefore, there was no generic way for applications to
specify non-default values used in OAEP and PSS padding. </p>
    <p> In J2SE 5, new parameter classes have been added to fully support
OAEP padding and the existing PSS parameter class was enhanced with
APIs to fully support RSA PSS signature implementations. Also, SunJCE
provider has been enhanced to accept <code>OAEPParameterSpec</code>
when OAEPPadding is used. </p>
    <p> The following classes have been added: </p>
    <ul>
      <li><a
 href="../../api/javax/crypto/spec/OAEPParameterSpec.html"> <code>javax.crypto.spec.OAEPParameterSpec</code></a>
      </li>
      <li><a href="../../api/javax/crypto/spec/PSource.html"> <code>javax.crypto.spec.PSource</code></a>
      </li>
      <li><a
 href="../../api/javax/security/spec/MGF1ParameterSpec.html"> <code>javax.security.spec.MGF1ParameterSpec</code></a>
      </li>
    </ul>
    <p>The following methods and fields have been added to <a
 href="../../api/java/security/spec/PSSParameterSpec.html"><code>java.security.spec.PSSParameterSpec</code></a>:
    </p>
    <pre>    public static final PSSParameterSpec DEFAULT<br>    public PSSParameterSpec(String mdName, String mgfName,<br>                            AlgorithmParameterSpec mgfSpec,<br>                            int saltLen, int trailerField)<br>    public String getDigestAlgorithm()<br>    public String getMGFAlgorithm()<br>    public AlgorithmParameterSpec getMGFParameters()<br>    public int getTrailerField()<br></pre>
  </blockquote>
</blockquote>
<h3><a name="EncryptedPrivateKeyInfo">Simplified Retrieval of <code>PKCS8EncodedKeySpec</code>
from <code>javax.crypto.EncryptedPrivateKeyInfo</code></a></h3>
<blockquote>
In J2SE 5, <code>javax.crypto.EncryptedPrivateKeyInfo</code> only has one
method, <code>getKeySpec(Cipher)</code> for retrieving the <code>PKCS8EncodedKeySpec</code>
from the encrypted data.
This limitation requires users to specify a cipher which is initialized
with the decryption key and parameters. When users only have the
decryption key, they would have to first retrieve the parameters out of
this <code>EncryptedPrivateKeyInfo</code> object, get hold of matching
  <code>Cipher</code> implementation, initialize it, and then call the <code>getKeySpec(Cipher)</code>
method.
  <p>To make <code>EncyptedPrivateKeyInfo</code> easier to use and to
make its API consistent with
  <code>javax.crypto.SealedObject</code>, the following methods have
been added to <a
 href="../../api/javax/crypto/EncryptedPrivateKeyInfo.html">
javax.crypto.EncryptedPrivateKeyInfo</a>:
  </p>
  <pre>    getKeySpec(Key decryptKey)<br>    getKeySpec(Key decryptKey, String provider)<br></pre>
</blockquote>
<h3><a name="DynamicKeyLength">Ability to Dynamically Determine Maximum
Allowable Key Length </a></h3>
<blockquote>
In 1.4.2, the crypto jurisdiction policy files bundled in J2SE limits
the maximum key length (and parameter value for some crypto algorithms)
that can be used for encryption/decryption. Users who desire unlimited
version of crypto jurisdiction files must download them separately.
  <p>Also, an exception is thrown when the Cipher instance is
initialized with keys (or parameters for certain crypto algorithms)
exceeds the maximum values allowed by the crypto jurisdiction files.
  </p>
  <p>In J2SE 5, the <code>Cipher</code> class has been updated to provide
the maximum values for key length and parameters configured in the
jurisdiction policy files, so that applications can use a shorter key
length when the default (limited strength) jurisdiction policy files
are installed.
  </p>
  <p>The following methods have been added to <a
 href="../../api/javax/crypto/Cipher.html"> javax.crypto.Cipher</a>:
  </p>
  <pre>    public static final int getMaxAllowedKeyLength(String transformation)<br>             throws NoSuchAlgorithmException<br><br>    public static final AlgorithmParameterSpec<br>             getMaxAllowedParameterSpec(String transformation)<br>             throws NoSuchAlgorithmException;<br></pre>
</blockquote>
<a name="SupportHMACSHA">
</a>
<h3><a name="SupportHMACSHA">Support for HmacSHA256, HmacSHA384,
HmacSHA512</a></h3>
<blockquote>
Support for HmacSHA-256, HmacSHA-384, and HmacSHA-512 algorithms have
been added to J2SE 5.
</blockquote>
<h3><a name="SupportRSAEncryption">Support for RSA Encryption to SunJCE
Provider</a></h3>
<blockquote>
A publicly accessible RSA encryption implementation has been added to
the SunJCE provider.
  <p><!--
[** Andreas: any additional documentation for the RSA support? **]-->
  </p>
</blockquote>
<h3><a name="SupportRC2-ARCFOUR">Support for RC2 and ARCFOUR Ciphers to
SunJCE Provider</a></h3>
<blockquote>
The SunJCE provider now implements the RC2 (<a
 href="http://www.ietf.org/rfc/rfc2268.txt">RFC 2268</a>) and ARCFOUR
(an RC4<sup><font size="-2">TM</font></sup>-compatible algorithm)
ciphers.
</blockquote>
<h3><a name="PBECiphers">Support for "PBEWithSHA1AndDESede" and
"PBEWithSHA1AndRC2_40" Ciphers</a></h3>
<blockquote>
Added support for PBEWithSHA1AndDESede and PBEWithSHA1AndRC2_40 ciphers
in SunJCE provider.
</blockquote>
<h3><a name="XMLEncryptionPadding">Support for XML Encryption Padding
Algorithm in JCE Block Encryption Ciphers</a></h3>
<blockquote>
W3C XML Encryption defines a new padding algorithm, "ISO10126Padding,"
for block ciphers. See
  <a href="http://www.w3.org/TR/xmlenc-core/#sec-Alg-Block"> 5.2 Block
Encryption Algorithms</a> for more information.
  <p>To allow Sun's provider to be used by XML Encryption
implementations and JSR 106 providers, we have added support for this
padding in J2SE 5.
  </p>
</blockquote>

<H1><a name="CoreClasses">Core Classes and Interfaces</a></H1>

<blockquote>

<P>
This section discusses the core classes and interfaces 
provided in the Java Cryptography Architecture: 

<ul>

<li>the <a href = "#Provider"><code>Provider</code></a> and 
<a href = "#Security"><code>Security</code></a> classes<p>

<li>the <a href = "#MessageDigest"><code>MessageDigest</code></a>, 
<a href = "#Signature"><code>Signature</code></a>, 
<a href = "#KPG"><code>KeyPairGenerator</code></a>, 
<a href = "#KeyFactory"><code>KeyFactory</code></a>, 
<a href = "#AlgorithmParameters"><code>AlgorithmParameters</code></a>, 
<a href = "#AlgorithmParameterGenerator"><code>AlgorithmParameterGenerator</code></a>,
<a href = "#CertificateFactory"><code>CertificateFactory</code></a>, 
<a href = "#KeyStore"><code>KeyStore</code></a>, 
<a href = "#SecureRandom"><code>SecureRandom</code></a>, 
<A HREF="../../api/java/security/cert/CertPathBuilder.html"><code>CertPathBuilder</code></A>, 
<A HREF="../../api/java/security/cert/CertPathValidator.html"><code>CertPathValidator</code></A>, and
<A HREF="../../api/java/security/cert/CertStore.html"><code>CertStore</code></A>.
</UL>


engine classes<p>

<li>the <a href = "#Key"><code>Key</code></a> interfaces and classes<p>

<li>the <a href = "#AlgSpec">Algorithm Parameter Specification Interfaces and 
Classes</a> and the 
<a href = "#KeySpecs">Key Specification Interfaces and Classes</a>

</ul>

<p>
This section shows the signatures of the main methods in each class
and interface. Examples for some of these classes
(<code>MessageDigest</code>, <code>Signature</code>, <code>KeyPairGenerator</code>, 
<code>SecureRandom</code>, <code>KeyFactory</code>,
and key specification classes)
are supplied in the corresponding 
<a href = "#Examples">Examples</a> sections.

The complete reference documentation for the relevant Security API packages
can be found in:
<ul>
   <LI><a href="../../api/java/security/package-summary.html">
<code>java.security package summary</code></a>
   <LI><a href="../../api/java/security/spec/package-summary.html">
<code>java.security.spec package summary</code></a>
   <LI><a href="../../api/java/security/interfaces/package-summary.html">
<code>java.security.interfaces package summary</code></a>
   <LI><a href="../../api/java/security/cert/package-summary.html">
<code>java.security.cert package summary</code></a>
</ul><p>


</blockquote>


<H2><a name="Provider">The <code>Provider</code> Class</a></H2>

<blockquote>

<p>The term "Cryptographic Service Provider" (used interchangeably 
with "provider" in this document) refers to a package or  
set of packages that supply a concrete implementation of a subset 
of the Java 2 SDK Security API cryptography features. 
The <code>Provider</code> <em>class</em> is the interface to such 
a package or set of packages.  It has methods for accessing the 
provider name, version number, and other information. Please note 
that in addition to registering implementations of cryptographic 
services, the <code>Provider</code> class can
also be used to register implementations of other security services that might 
get defined as part of the Java 2 SDK Security API or one of its extensions.

<p>To supply implementations of cryptographic services, 
an entity (e.g., a development group) 
writes the implementation code and creates a subclass of the 
<code>Provider</code> class. The constructor of the <code>Provider</code>
subclass sets the values of various properties; the Java 2 SDK 
Security API uses these values to look up the services 
that the provider implements. In other words, the subclass 
specifies the names of the classes implementing the services. 

<p>There are several types of services that can be implemented by 
provider packages; for more information, 
see <a href = "#Engine">Engine Classes and Algorithms</a>.

<p>The different implementations may have different
characteristics. Some may be software-based, while others may be
hardware-based. Some may be platform-independent, while others may be
platform-specific. Some provider source code may be available for
review and evaluation, while some may not.
The Java Cryptography Architecture (JCA) lets both end-users and 
developers decide what their needs
are. 

<P>In this section we explain how end-users install the
cryptography implementations that fit their needs, and how developers
request the implementations that fit theirs.

<blockquote>
<hr>
<B>Note:</B> For information about implementing a provider, see
the guide <a href = "HowToImplAProvider.html">How To Implement a Provider for
the Java Cryptography Architecture</a>.
<hr>
</blockquote>


<H3><a name="ProviderImplReq">How Provider Implementations Are Requested 
and Supplied</a></H3>

<blockquote>

For each <a href = "#Engine">engine class</a> in the API, a particular 
implementation is requested and instantiated by calling a 
<code>getInstance</code> method on the engine class, specifying 
the name of the desired algorithm and, optionally, the name
of the provider (or the <code>Provider</code> class) whose implementation is desired.

<p>If no provider is specified, <code>getInstance</code> 
searches the registered providers for an
implementation of the requested cryptographic service 
associated with the named algorithm.
In any given Java Virtual Machine (JVM), providers are 
<a href = "#ProviderInstalling">installed</a> in a 
given <i>preference order</i>, the order in which 
the provider list is searched if a specific provider is not 
requested. For example, suppose there are two providers 
installed in a JVM, <code>PROVIDER_1</code> and 
<code>PROVIDER_2</code>. Assume that: 

<ul>
<li><code>PROVIDER_1</code> implements SHA1withDSA, SHA-1, MD5, DES, and DES3. <BR>
<code>PROVIDER_1</code> 
has preference order 1 (the highest priority).<p>
<li><code>PROVIDER_2</code> implements SHA1withDSA, MD5withRSA, MD2withRSA, MD2, MD5, 
RC4, RC5, DES, and RSA. 
<BR><code>PROVIDER_2</code> has preference order 2.
</ul>

Now let's look at three scenarios:
<OL>
<LI>If we are looking for an MD5 implementation. Both providers
supply such an implementation. The <code>PROVIDER_1</code> implementation is returned
since <code>PROVIDER_1</code> has the highest priority and is searched first.

<LI>If we are looking for an MD5withRSA signature
algorithm, <code>PROVIDER_1</code> is first searched for it. No implementation is
found, so <code>PROVIDER_2</code> is searched. Since an implementation is found, it
is returned.

<LI>
Suppose we are looking for a SHA1withRSA signature
algorithm. Since no installed provider implements it, a 
<code>NoSuchAlgorithmException</code> is thrown.
</OL>

<p>
The <code>getInstance</code> methods that include a provider argument 
are for developers who want to specify which provider they want 
an algorithm from. A federal agency, for example, will want 
to use a provider implementation that has received federal certification. 
Let's assume that the SHA1withDSA implementation from
<code>PROVIDER_1</code> has not received such certification, while the DSA
implementation of <code>PROVIDER_2</code> has received it.

<p>A federal agency program would then have the following call, specifying
<code>PROVIDER_2</code> since it has the certified implementation:

<blockquote>
<pre>
Signature dsa = Signature.getInstance("SHA1withDSA", "PROVIDER_2");
</pre>
</blockquote>

<p>In this case, if <code>PROVIDER_2</code> was not installed, a
<code>NoSuchProviderException</code> would be thrown, even if another 
installed provider implements the algorithm requested. 

<p>A program also has the option of getting a list of all 
the installed providers
(using the <code>getProviders</code> method in the 
<a href = "#Security"><code>Security</code></a> class) 
and choosing one from the list.

</blockquote>

<H3><a name="ProviderInstalling">Installing Providers</a></H3>

<blockquote>

<p>There are two parts to installing a provider: installing the provider
package classes, and configuring the provider.

<H4>Installing the Provider Classes</H4>

<p>There are two possible ways to install the provider classes:

<ol>

<li>Place a zip or JAR file containing the classes
anywhere in your classpath.<p>

<li>Supply your provider JAR file as an "installed" or "bundled"
extension. For more information on how to deploy an extension, 
see <a href = "../extensions/spec.html#deployment">
How is an extension deployed?</a>.

</ol>

<H4>Configuring the Provider</H4>

<p>The next step is to add the provider to your list of approved
providers. This step can be done statically by editing the 
<code>java.security</code> file in the <code>lib/security</code> 
directory of the SDK; therefore, if the SDK is installed in a directory 
called <code>j2sdk1.2</code>, the file would be 
<code>j2sdk1.2/lib/security/java.security</code>.

One of the types of properties you can set in <code>java.security</code>
has the following form:

<blockquote>
<pre>
security.provider.<i>n</i>=<i>masterClassName</i>
</pre>
</blockquote>

<p>This declares a provider, and specifies its preference order
<i>n</i>. The preference order is the order in which providers are
searched for requested algorithms (when no specific provider is 
requested). The order is 1-based: 1 is the most preferred, followed
by 2, and so on.

<p><i><code>masterClassName</code></i> must specify  the provider's master
class. The provider's documentation will specify its master
class. This class is always a subclass of the <code>Provider</code>
class. The subclass constructor sets the values of various properties that are 
required for the Java Cryptography API to look up the algorithms or other 
facilities the provider implements.

<p>Suppose that the master class is <code>COM.acme.provider.Acme</code>,
and that you would like to configure <code>Acme</code> as your third preferred
provider. To do so, you would add the following line to the <code>java.security</code>
file:

<blockquote>
<pre>
security.provider.3=COM.acme.provider.Acme
</pre>
</blockquote>

Providers may also be registered dynamically. To do so, call either 
the <code>addProvider</code> or
<code>insertProviderAt</code> method in the <code>Security</code> class.
This type of registration is not persistent and can only be
done by "trusted" programs. See <a href = "#Security">Security</a>.


</blockquote>

<H3><code>Provider</code> Class Methods</H3>

<blockquote>

<p>Each <code>Provider</code>class instance has a (currently case-sensitive) name, 
a version number, and a string 
description of the provider and its services. You can query the <code>Provider</code>
instance for this information by calling the following methods:

<blockquote>
<pre>
public String getName()
public double getVersion()
public String getInfo()
</pre>
</blockquote>

</blockquote>
</blockquote>

<H2><a name="Security">The <code>Security</code> Class</a></H2>

<blockquote>

<p>
The <code>Security</code> class manages installed providers and security-wide
properties. It only contains static methods and is never instantiated.

The methods for adding or removing providers, and for 
setting <code>Security</code> properties, can only be executed by a
trusted program. Currently, a "trusted program" is either 

<ul>

<li>a local application not running under a security manager, or<p>

<li>an applet or application with permission to execute the 
specified method (see below).

</ul>

The determination that code is considered trusted to perform
an attempted action (such as adding a provider)
requires that the applet is granted permission for that particular
action. 

<p>For example, in the Policy reference implementation, 
the policy configuration file(s) for a SDK installation
specify what permissions (which types of system resource accesses) are
allowed by code from specified code sources.
(See below and the 
<a href="PolicyFiles.html">
"Default Policy Implementation and Policy File Syntax"</a> and 
<a href="spec/security-spec.doc.html"> 
"Java Security Architecture Specification"</a> files 
for more information.)

<p>Code being executed is always considered to come from a particular
"code source". The code source includes not only the location (URL)
where the applet originated from, but also a reference to the public key(s) 
corresponding to the private key(s) used to sign the code.
Public keys in a code source are referenced by (symbolic) alias
names from the user's <a href = "#KeyManagement">keystore</a> .

<p>In a policy configuration file, a code source is represented by two components:
a code base (URL), and an alias name (preceded by <code>signedBy</code>), where
the alias name identifies the keystore entry containing the public key 
that must be used to verify the code's signature.

<p>Each "grant" statement in such a file grants a specified code source 
a set of permissions, specifying which actions are allowed.

<p>Here is a sample policy configuration file:
  
<blockquote>
<pre>
grant codeBase "file:/home/sysadmin/", signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
    permission java.security.SecurityPermission "putProviderProperty.*";
};
</pre>
</blockquote>

This configuration file specifies that <i>only</i> code 
loaded from a signed JAR file from beneath the <code>/home/sysadmin/</code> 
directory on the local file system can add or remove providers 
or set provider properties. 
(Note that the signature of the JAR file can be verified using the public key 
referenced by the alias name <code>sysadmin</code> in the user's keystore.) 

<p>Either component of the code source (or both) may be missing. Here's an  
example of a configuration file where <code>codeBase</code> is missing:
<blockquote>
<pre>
grant signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
</blockquote>
If this policy is in effect, code that comes in a JAR File signed by <code>sysadmin</code> 
can add/remove providers--regardless of where the JAR File originated.

<p>Here's an example without a signer:

<blockquote>
<pre>
grant codeBase "file:/home/sysadmin/" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
</blockquote>

In this case, code that comes from anywhere within the <code>/home/sysadmin/</code> 
directory on the local filesystem can add/remove providers. The code does
not need to be signed.

<p>An example where neither <code>codeBase</code> nor <code>signedBy</code> is included is:

<blockquote>
<pre>
grant {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</pre>
</blockquote>

Here, with both code source components missing, any code (regardless of where
it originates, or whether or not it is signed, or who signed
it) can add/remove providers.


<H3>Managing Providers</H3>

<BLOCKQUOTE>
  <P>The following tables summarize the methods in the <CODE>Security</CODE>
  class you can use to query which <CODE>Provider</CODE>s are installed,
  as well as to install or remove providers at runtime.</P>

  <P><TABLE summary="querying providers" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD COLSPAN="2" BGCOLOR="#dedeef">
      <P><CENTER><B>Quering Providers</B></CENTER></TD>
    </TR>
	<thead>
    <TR>
      <TH WIDTH="280">
      <B>Method</B></TH> 
      <TH WIDTH="420">
      <B>Description</B></TH> 
    </TR>
	</thead>
    <TR>
      <TD WIDTH="280">
      <CODE>static Provider[] getProviders()</CODE></TD> 
      <TD WIDTH="420">
      Returns an array containing all the installed providers
      (technically, the <CODE>Provider</CODE>
      subclass for each package provider). The order of the <CODE>
      Provider</CODE>s in the array is their preference
      order.</TD> 
    </TR>
    <TR>
      <TD WIDTH="280">
      <CODE>static Provider getProvider<BR>
      (String providerName)</CODE></TD> 
      <TD WIDTH="420">
      Returns the <CODE>Provider</CODE> named
      <CODE>providerName</CODE>. It returns
      <CODE>null</CODE> if the <CODE>Provider</CODE>
      is not found.</TD> 
    </TR>
  </TABLE></P>
  <P><TABLE WIDTH="700" summary="adding providers" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD COLSPAN="2" BGCOLOR="#dedeef">
      <P><CENTER><B>Adding Providers</B></CENTER></TD>
    </TR>
	<thead>
    <TR>
      <TH WIDTH="280">
      <B>Method</B></TH> 
      <TH WIDTH="420">
      <B>Description</B></TH> 
    </TR>
	</thead>
    <TR>
      <TD>
      <PRE><CODE>static int <BR>addProvider(Provider provider)</CODE></PRE>
</TD>
      <TD>
      Adds a <CODE>Provider</CODE>
      to the end of the list of installed <CODE>Provider</CODE>s.
      It returns the preference position in which the <CODE>Provider</CODE>
      was added, or <CODE>-1</CODE> if the <CODE>Provider</CODE> was not added because it was
      already installed.</TD> 
    </TR>
    <TR>
      <TD>
      <CODE>static int insertProviderAt<BR>
      (Provider provider, int position)</CODE>
</TD>
      <TD>
      <P>Adds a new <CODE>Provider</CODE> at
      a specified position. If the given provider
      is installed at the requested position, the provider formerly
      at that position and all providers with a position greater than
      <CODE>position</CODE> are shifted up one
      position (towards the end of the list). 
      This method returns the preference position in which
      the <CODE>Provider</CODE> was added, or
      <CODE>-1</CODE> if the <CODE>Provider</CODE>
      was not added because it was already installed.</TD> 
    </TR>
  </TABLE></P>
  <P><TABLE WIDTH="700" summary="removing providers" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD COLSPAN="2" BGCOLOR="#dedeef">
      <P><CENTER><B>Removing Providers</B></CENTER></TD>
    </TR>
	<thead>
    <TR>
      <TH WIDTH="280">
      &nbsp;<B>Method</B></TH> 
      <TH WIDTH="420">
      &nbsp;<B>Description</B></TH> 
    </TR>
	</thead>
    <TR>
      <TD WIDTH="280">
      <CODE>static void removeProvider(String name)</CODE>
</TD>
      <TD WIDTH="420">
      Removes the <CODE>Provider</CODE> with
      the specified name. It returns silently if the provider is not
      installed. When the specified provider is removed, all providers
      located at a position greater than where the specified provider
      was are shifted down one position (towards the head of the list
      of installed providers).</TD> 
    </TR>
  </TABLE></P>

  <blockquote>
  <HR ALIGN=LEFT>
  <B>Note:</B> If you want to change the preference position
  of a provider, you must first remove it, and then insert it back
  in at the new preference position.
  <HR ALIGN=LEFT>
  </BLOCKQUOTE>

  </BLOCKQUOTE>

<H3>Security Properties</H3>

<blockquote>

<p>The <code>Security</code> class maintains a list of system-wide security
properties. These properties are accessible and settable by a
trusted program via the following methods:

<BLOCKQUOTE>
<pre>
static String getProperty(String key)
static void setProperty(String key, String datum)
</pre>
</BLOCKQUOTE>


</blockquote>

</blockquote>


<H2><a name="MessageDigest">The <code>MessageDigest</code> Class</a></H2>

<blockquote>

<P>
The <code>MessageDigest</code> class is an <a href = "#Engine">engine class</a> 
designed to provide
the functionality of cryptographically secure message digests
such as SHA-1 or MD5. A cryptographically secure message digest
takes arbitrary-sized input (a byte array), and generates a fixed-size
output, called a <I>digest</I> or hash. A digest has two 
properties:
<UL>
<LI>It should be computationally infeasible to find two messages that
hashed to the same value.<p>
<LI>The digest should not reveal anything about the input that was
used to generate it.
</UL>

<P>
Message digests are used to produce unique and reliable identifiers
of data. They are sometimes called the "digital fingerprints"
of data.


<H3>Creating a <code>MessageDigest</code> Object</H3>

<blockquote>

<P>
The first step for computing a digest is to create a message digest
instance. As with all engine classes, the 
way to get a <code>MessageDigest</code> object for a particular type of message 
digest algorithm is to call the <code>getInstance</code>
static factory method on the <code>MessageDigest</code> class:

<blockquote>
<pre>
static MessageDigest getInstance(String algorithm) 
</pre>
</blockquote>

<blockquote>
<HR>
<B>Note:</B> The algorithm name is not case-sensitive. For example, all the
following calls are equivalent:

<blockquote>
<pre>
MessageDigest.getInstance("SHA-1")
MessageDigest.getInstance("sha-1")
MessageDigest.getInstance("sHa-1")
</pre>
</blockquote>
<HR>
</blockquote>

<p>A caller may optionally specify the name of a provider or a  
<code>Provider</code> instance, 
which guarantees that the implementation of the algorithm requested is from the
specified provider:
<P>

<blockquote>
<pre>
static MessageDigest getInstance(String algorithm, String provider)
static MessageDigest getInstance(String algorithm, Provider provider)
</pre>
</blockquote>

<P>
A call to <code>getInstance</code> returns an initialized message 
digest object. It thus does not need further initialization.


</blockquote>

<H3>Updating a Message Digest Object</H3>

<blockquote>

<P>
The next step for calculating the digest of some data is to supply
the data to the initialized
message digest object. This is done by calling one of 
the <code>update</code> methods:
<P>

<blockquote>
<pre>
void update(byte input)
void update(byte[] input)
void update(byte[] input, int offset, int len)
</pre>
</blockquote>


</blockquote>

<H3>Computing the Digest</H3>

<blockquote>

<P>
After the data has been supplied by calls to <code>update</code> methods,
the digest is computed using a call to one of the
<code>digest</code> methods:
<P>

<blockquote>
<pre>
byte[] digest()
byte[] digest(byte[] input)
int digest(byte[] buf, int offset, int len)
</pre>
</blockquote>

<P>The first two methods return the computed digest.
The latter method stores the computed digest in the provided buffer
<code>buf</code>, starting at <code>offset</code>. <code>len</code> is
the number of bytes in <code>buf</code> allotted for the digest.
The method returns the number of bytes actually stored in <code>buf</code>.

<P>
A call to the <code>digest</code> method that takes an input byte array 
argument is equivalent to making a call to

<blockquote>
<pre>
void update(byte[] input)
</pre>
</blockquote>

with the specified input, followed by a call to the <code>digest</code>
method without any arguments.

<p>
Please see the <a href = "#MDEx">Examples</a> section for more details.

</blockquote>

</blockquote>


<H2><a name="Signature">The <code>Signature</code> Class</a></H2>

<blockquote>

The <code>Signature</code> class is an <a href = "#Engine">engine class</a> 
designed to provide the
functionality of a cryptographic digital signature algorithm such as DSA or
RSA with MD5. A cryptographically secure signature algorithm takes
arbitrary-sized input and a private key and generates a relatively
short (often fixed-size) string of bytes, called the <i>signature</i>, 
with the following properties:

<UL>
<LI>Given the public key corresponding to the private key used
to generate the signature, it should be possible to verify the
authenticity and integrity of the input.<p>
<LI>The signature and the public key do not reveal anything about
the private key.
</UL>

<P>
A <code>Signature</code> object can be used to sign data. It can also be used to 
verify whether or not an alleged signature is in fact the authentic 
signature of the data associated with it. 

Please see the <a href = "#SigEx">Examples</a> section for an example
of signing and verifying data.

<H3><code>Signature</code> Object States</H3>

<blockquote>

<code>Signature</code> objects are modal objects. This means that a <code>Signature</code> 
object is always in a given state, where it may only do
one type of operation. States are represented as final integer constants
defined in their respective classes.
<P>
The three states a <code>Signature</code> object may have are:
<UL>
<LI><code>UNINITIALIZED</code>
<LI><code>SIGN</code>
<LI><code>VERIFY</code>
</UL>

When it is first created, a <code>Signature</code> object is in the 
<code>UNINITIALIZED</code> state. 
The <code>Signature</code> class defines two initialization methods,
<code>initSign</code> and <code>initVerify</code>, which change the
state to <code>SIGN</code> and <code>VERIFY</code>, respectively.

</blockquote>

<H3>Creating a <code>Signature</code> Object</H3>

<blockquote>

The first step for signing or verifying a signature is to create a 
<code>Signature</code> instance.  As with all engine classes, the 
way to get a <code>Signature</code> object for a particular type of signature
algorithm is to call the <code>getInstance</code>
static factory method on the <code>Signature</code> class:

<blockquote>
<pre>
static Signature getInstance(String algorithm)
</pre>
</blockquote>

<blockquote>
<HR>
<B>Note:</B> The algorithm name is not case-sensitive.
<HR>
</blockquote>

A caller may optionally specify the name of a provider or the 
<code>Provider</code> class, which will 
guarantee that the implementation of the algorithm requested is from the
named provider:
<P>

<blockquote>
<pre>
static Signature getInstance(String algorithm, String provider)
static Signature getInstance(String algorithm, Provider provider)

</pre>
</blockquote>

</blockquote>

<H3>Initializing a <code>Signature</code> Object</H3>

<blockquote>
<P>
A <code>Signature</code> object must be initialized before it is used. The 
initialization method depends on whether the object is going 
to be used for signing or for verification.

<p>If it is going to be used for signing, the object 
must first be initialized with the private key of the entity whose 
signature is going to be generated. This initialization is done by 
calling the method:

<blockquote>
<pre>
final void initSign(PrivateKey privateKey)
</pre>
</blockquote>

This method puts the <code>Signature</code> object in the <code>SIGN</code> state.

<p>If instead the <code>Signature</code> object is going to be used for verification, 
it must first be initialized with the public key of the entity whose 
signature is going to be verified. This initialization is done by 
calling either of these methods:
<P>

<pre>
    final void initVerify(PublicKey publicKey)

    final void initVerify(Certificate certificate)
</pre>

<P>
This method puts the <code>Signature</code> object in the 
<code>VERIFY</code> state.

</blockquote>

<H3>Signing</H3>

<blockquote>

<P>
If the <code>Signature</code> object has been initialized for signing (if it
is in the <code>SIGN</code> state), the data to be signed can then be supplied 
to the object. This is done by making one or more calls to
one of the <code>update</code> methods:
<P>

<blockquote>
<pre>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</pre>
</blockquote>

<P>
Calls to the <code>update</code> method(s) should be made until 
all the data to be signed has been supplied to the 
<code>Signature</code> object.

<P>
To generate the signature, simply call one of the <code>sign</code> methods:

<blockquote>
<pre>
final byte[] sign()
final int sign(byte[] outbuf, int offset, int len)
</pre>
</blockquote>

<P>
The first method returns the signature result in a byte array. 
The second stores the signature result in the provided buffer
<i>outbuf</i>, starting at <i>offset</i>. <i>len</i> is
the number of bytes in <i>outbuf</i> allotted for the signature.
The method returns the number of bytes actually stored.

<p>Signature encoding is algorithm specific. 
See <a href = "#AppB">Appendix B</a> for 
more information about
the use of ASN.1 encoding in the Java Cryptography Architecture. 

<p>A call to a <code>sign</code> method resets the signature object to 
the state it was in when previously initialized for signing via a
call to <code>initSign</code>. That is, the object is 
reset and available to generate another signature with the same
private key, if desired, via new calls to <code>update</code> and 
<code>sign</code>. 

<p>Alternatively, a new call can be made to <code>initSign</code>
specifying a different private key, or
to <code>initVerify</code> (to initialize the <code>Signature</code> object to 
verify a signature).
  

</blockquote>


<H3>Verifying</H3>

<blockquote>

<P>
If the <code>Signature</code> object has been initialized for verification (if it
is in the <code>VERIFY</code> state), it can then verify
if an alleged signature is in fact the authentic signature 
of the data associated with it. To start the process, the data to be 
verified (as opposed to the signature itself) is supplied
to the object. The data is passed to the object by calling 
one of the <code>update</code> methods:

<blockquote>
<pre>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</pre>
</blockquote>

<P>
Calls to the <code>update</code> method(s) should be made until 
all the data to be verified has been supplied to the 
<code>Signature</code> object. 
The signature can now be verified by calling one of 
the <code>verify</code> methods:

<blockquote>
<pre>
final boolean verify(byte[] signature)

final boolean verify(byte[] signature, int offset, int length)
</pre>
</blockquote>

<P>
The argument must be a byte array containing the signature. 
The argument must be a byte array containing the 
signature. This byte array would hold the signature bytes 
which were returned by a previous call to one of the <code>sign</code> methods.

<p>
The <code>verify</code> method returns a <code>boolean</code> indicating
whether or not the 
encoded signature is the authentic signature of the data
supplied to the <code>update</code> method(s).

<p>A call to the <code>verify</code> method resets the signature object to 
its state when it was initialized for verification via a 
call to <code>initVerify</code>. That is, the object is 
reset and available to verify another signature from the identity
whose public key was specified in the call to <code>initVerify</code>.     

<p>Alternatively, a new call can be made to <code>initVerify</code>
specifying a different public key (to initialize the <code>Signature</code> 
object for verifying a signature from a different entity), or
to <code>initSign</code> (to initialize the <code>Signature</code> object for 
generating a signature).

</blockquote>

</blockquote>


<H2><a name="AlgParms">Algorithm Parameters Classes</a></H2>

<blockquote>


<H3><a name="AlgSpec">Algorithm Parameter Specification Interfaces and 
Classes</a></H3>

<blockquote>

<P>An algorithm parameter specification is a transparent representation of 
the sets of parameters used with an algorithm.

<p>A <i>transparent</i> representation of a set of parameters 
means that you can access each parameter value in the set individually. You can 
access these values  through one of the <code>get</code> methods defined
in the corresponding specification class (e.g., <code>DSAParameterSpec</code>
defines <code>getP</code>, <code>getQ</code>, and
<code>getG</code> methods, to access <code>p</code>, <code>q</code>, 
and <code>g</code>, respectively).

<p>In contrast, the 
<a href = "#AlgorithmParameters"><code>AlgorithmParameters</code></a> class supplies 
an <i>opaque</i> representation, in which
you have no direct access to the parameter fields. 
You can only get the name of the algorithm associated with the
parameter set (via <code>getAlgorithm</code>) and some kind of encoding for the 
parameter set (via <code>getEncoded</code>).

<p>The algorithm parameter specification interfaces and classes in 
the <code>java.security.spec</code> package are described in the following sections.


<H3><a name="AlgorithmParameterSpec">The <code>AlgorithmParameterSpec</code> Interface</a></H3>

<blockquote>

<code>AlgorithmParameterSpec</code>  is an interface to a transparent specification of
cryptographic parameters.

<p>This interface contains no methods or constants. Its only purpose
is to group (and provide type safety for) all parameter specifications.
All parameter specifications must implement this interface.

</blockquote>


<H3><a name="DSAParameterSpec">The <code>DSAParameterSpec</code> Class</a></H3>

<blockquote>

This class (which implements the <code>AlgorithmParameterSpec</code> interface) 
specifies the set of parameters used with the DSA algorithm.
It has the following methods:

<blockquote>
<pre>
BigInteger getP()
BigInteger getQ()
BigInteger getG()
</pre>
</blockquote>

These methods return the DSA algorithm
parameters: the prime <code>p</code>, 
the sub-prime <code>q</code>, and the base <code>g</code>.

</blockquote>

</blockquote>


<H3><a name="AlgorithmParameters">The <code>AlgorithmParameters</code>  Class</a></H3>

<blockquote>

The <code>AlgorithmParameters</code> class is an <a href = "#Engine">engine class</a> 
that provides an opaque representation of cryptographic parameters.

<p>An <i>opaque</i> representation is one in which
you have no direct access to the parameter fields;
you can only get the name of the algorithm associated with the
parameter set and some kind of encoding for the 
parameter set. This is in contrast to a
<i>transparent</i> representation of parameters, in which you can access
each value individually, through one of the <code>get</code> methods defined
in the corresponding <a href = "#AlgSpec">specification class</a>.
Note that you can call the <code>AlgorithmParameters</code>  <code>getParameterSpec</code> method to
convert an <code>AlgorithmParameters</code> object to a transparent
specification (see the following section).


<H3>Creating an <code>AlgorithmParameters</code> Object</H3>

<blockquote>

<P>
As with all engine classes, the 
way to get an <code>AlgorithmParameters</code> object for a particular type of 
algorithm is to call the <code>getInstance</code>
static factory method on the <code>AlgorithmParameters</code> class:
<P>

<blockquote>
<pre>
static AlgorithmParameters getInstance(String algorithm) 
</pre>
</blockquote>

<blockquote>
<hr>
<B>Note:</B> The algorithm name is not case-sensitive.
<hr>
</blockquote>

A caller may optionally specify the name of a provider or the 
<code>Provider</code> class, which will 
guarantee that the algorithm parameter implementation requested is from
the named provider:

<blockquote>
<pre>
static AlgorithmParameters getInstance(String algorithm, String provider)
static AlgorithmParameters getInstance(String algorithm, Provider provider)

</pre>
</blockquote>

</blockquote>


<H3>Initializing an <code>AlgorithmParameters</code>  Object</H3>

<blockquote>

<p>Once an <code>AlgorithmParameters</code>  object is instantiated, it must be
initialized via a call to <code>init</code>, using an appropriate parameter
specification or parameter encoding:

<blockquote>
<pre>
void init(AlgorithmParameterSpec paramSpec) 
void init(byte[] params)
void init(byte[] params, String format)
</pre>
</blockquote>

In these <code>init</code> methods, 
<code>params</code> is an array containing the encoded parameters, 
and <code>format</code> is the name of the decoding format. In the 
<code>init</code> method with a <code>params</code> argument but 
no <code>format</code> argument, the
primary decoding format for parameters is used. The primary decoding
format is ASN.1, if an ASN.1 specification for the parameters
exists.

<blockquote>
<hr>
<B>Note:</B> <code>AlgorithmParameters</code> objects can 
be initialized only once. They are not reusable.
<hr>
</blockquote>

</blockquote>

<H3>Obtaining the Encoded Parameters</H3>

<blockquote>

<p>A byte encoding of the parameters represented in an <code>AlgorithmParameters</code> 
object may be obtained via a call to <code>getEncoded</code>:

<blockquote>
<pre>
byte[] getEncoded() 
</pre>
</blockquote>

This method returns the parameters in their primary encoding format.
The primary encoding format for parameters is ASN.1, if an ASN.1
specification for this type of parameters exists.

<p>If you want the parameters returned in a specified encoding format,
use
<blockquote>
<pre>
byte[] getEncoded(String format)
</pre>
</blockquote>

If <code>format</code> is null, the primary encoding format for parameters is used,
as in the other <code>getEncoded</code> method.

<blockquote>
<hr>
<B>Note:</B> In the default <code>AlgorithmParameters</code> 
 implementation, supplied 
 by the "SUN" provider, the <code>format</code> argument 
 is currently ignored.
<hr>
</blockquote>


</blockquote>


<H3>Converting an <code>AlgorithmParameters</code> Object to a Transparent Specification</H3>

<blockquote>

<p>A transparent parameter specification for the algorithm parameters
may be obtained from an <code>AlgorithmParameters</code> object via a call to
<code>getParameterSpec</code>:

<blockquote>
<pre>
AlgorithmParameterSpec getParameterSpec(Class paramSpec)
</pre>
</blockquote>

<code>paramSpec</code> identifies the specification class in which 
the parameters should be returned. The specification class could be, 
for example, <code>DSAParameterSpec.class</code> to indicate that the
parameters should be returned in an instance of the 
<a href = "#DSAParameterSpec"><code>DSAParameterSpec</code></a> class.
(This class is in the <code>java.security.spec</code> package.)

</blockquote>

</blockquote>

<H3><a name="AlgorithmParameterGenerator">The 
<code>AlgorithmParameterGenerator</code> Class</a></H3>

<blockquote>

The <code>AlgorithmParameterGenerator</code> class 
is an <a href = "#Engine">engine class</a> 
used to generate a set of parameters suitable for a certain algorithm
(the algorithm specified when an <code>AlgorithmParameterGenerator</code> instance
is created).

<H3>Creating an <code>AlgorithmParameterGenerator</code> Object</H3>

<blockquote>

<P>
As with all engine classes, the 
way to get an <code>AlgorithmParameterGenerator</code> object for a particular type of 
algorithm is to call the <code>getInstance</code>
static factory method on the <code>AlgorithmParameterGenerator</code>  class:
<P>

<blockquote>
<pre>
static AlgorithmParameterGenerator getInstance(
                                   String algorithm)
</pre>
</blockquote>

<blockquote>
<hr>
<b>Note:</b> The algorithm name is not case-sensitive. 
<hr>
</blockquote>

<P>
A caller may optionally specify the name of a provider 
or the <code>Provider</code> class, which will 
guarantee that the algorithm parameter generator implementation is from the
named provider:

<blockquote>
<pre>
static AlgorithmParameterGenerator getInstance(
                                   String algorithm, 
                                   String provider)

static AlgorithmParameterGenerator getInstance(
                                   String algorithm, 
                                   Provider provider)
</pre>
</blockquote>
</blockquote>


<H3>Initializing an <code>AlgorithmParameterGenerator</code> Object</H3>

<blockquote>

<P>The <code>AlgorithmParameterGenerator</code> object can be initialized
in two different ways: an algorithm-independent manner or an
algorithm-specific manner. 

<P>The algorithm-independent approach uses the fact that all parameter
generators share the concept of a "size" and a
source of randomness. The measure of size is universally shared 
by all algorithm parameters, though it is interpreted differently
for different algorithms. For example, in the case of parameters
for the DSA algorithm, "size" corresponds to the size of the
prime modulus, in bits.
(See <a href = "#AppB">Appendix B</a>: Algorithms for 
information about the sizes for specific algorithms.) 
When using this approach, algorithm-specific parameter generation
values--if any--default to some standard values. 

One <code>init</code> method that
takes these two universally shared types of arguments:

<blockquote>
<pre>
void init(int size, SecureRandom random);
</pre>
</blockquote>

Another <code>init</code> method takes only a <code>size</code>
argument and uses a system-provided source of randomness:

<blockquote>
<pre>
void init(int size)
</pre>
</blockquote>

<P>A third approach initializes a parameter generator object
using algorithm-specific semantics, which are represented by a set of
algorithm-specific parameter generation values supplied in an
<code>AlgorithmParameterSpec</code> object:

<blockquote>
<pre>
void init(AlgorithmParameterSpec genParamSpec,
                          SecureRandom random)

void init(AlgorithmParameterSpec genParamSpec)
</pre>
</blockquote>

To generate Diffie-Hellman system parameters, for example, the 
parameter generation values usually
consist of the size of the prime modulus and the size of the
random exponent, both specified in number of bits.
(The Diffie-Hellman algorithm has been part of the JCE since  
JCE 1.2.)

</blockquote>


<H3>Generating Algorithm Parameters</H3>

<blockquote>

Once you have created and initialized an <code>AlgorithmParameterGenerator</code> 
object, you can use the
<code>generateParameters</code> method to generate the algorithm parameters:

<blockquote>
<pre>
AlgorithmParameters generateParameters()
</pre>
</blockquote>

</blockquote>

</blockquote>

</blockquote>




<H2><a name="Key"><code>Key</code> Interfaces</a></H2>

<blockquote>

<P>
The <code>Key</code> interface is the top-level interface for all opaque keys. It
defines the functionality shared by all opaque key objects. 

<p>An <i>opaque</i> key representation is one in which
you have no direct access to the key material that constitutes a key.
In other words: "opaque" gives you limited access to the key--just
the three methods defined by the <code>Key</code> interface (see below): 
<code>getAlgorithm</code>, <code>getFormat</code>, and <code>getEncoded</code>.

This is in contrast to a
<i>transparent</i> representation, in which you can access
each key material value individually, through one of the <code>get</code> 
methods defined in the corresponding <a href = "#KeySpec">specification class</a>.

<p>All opaque keys have three characteristics:

<blockquote>
<DL>
<DT><b>An Algorithm</b></DT>

<DD>
The key algorithm for that key. The key algorithm is usually
an encryption or asymmetric operation algorithm (such as DSA or
RSA), which will work with those algorithms and with related
algorithms (such as MD5 with RSA, SHA-1 with RSA, etc.)
The name of the algorithm of a key is obtained using this method:

<blockquote>
<pre>
String getAlgorithm()
</pre>
</blockquote>


<DT><B>An Encoded Form</b></DT>

<DD>
The external encoded form for the key used when a standard
representation of the key is needed outside the Java Virtual Machine,
as when transmitting the key to some other party. The key
is encoded according to a standard format (such as X.509
or PKCS #8), and is returned using the method:
<P>

<blockquote>
<pre>
byte[] getEncoded()
</pre>
</blockquote>


<DT><B>A Format</b></DT>

<DD>
The name of the format of the encoded key. It is returned by 
the method:
<blockquote>
<pre>
String getFormat()
</pre>
</blockquote>
</DL>
</blockquote>

Keys are generally obtained through key generators, certificates,
key specifications (using a <a href = "#KeyFactory"><code>KeyFactory</code></a>),
or a <a href = "#KeyStore"><code>KeyStore</code></a> implementation accessing 
a keystore database used to manage keys. 

<p>It is possible to parse encoded keys, in an algorithm-dependent 
manner, using a <a href = "#KeyFactory"><code>KeyFactory</code></a>.

<p>It is also possible to parse certificates, using a
<a href = "#CertificateFactory"><code>CertificateFactory</code></a>.


<P>
Here is a list of interfaces which extend the <code>Key</code> 
interface in the <code>java.security.interfaces</code> package: 
<TABLE summary="layout">
<TR>

<TD>
<UL>
<LI><a href = "../../api/javax/crypto/interfaces/DHPrivateKey.html">DHPrivateKey</A>
<LI><a href = "../../api/javax/crypto/interfaces/DHPublicKey.html">DHPublicKey</A>
<LI><a href = "../../api/java/security/interfaces/DSAPrivateKey.html">DSAPrivateKey</A> 
<LI><a href = "../../api/java/security/interfaces/DSAPublicKey.html">DSAPublicKey</A> 
<LI><a href = "../../api/javax/crypto/interfaces/PBEKey.html">PBEKey</A> 
<LI><a href = "../../api/java/security/PrivateKey.html">PrivateKey</A> 
</UL>
</TD>
<TD>
<UL>
<LI><a href = "../../api/java/security/PublicKey.html">PublicKey</A> 
<LI><a href = "../../api/java/security/interfaces/RSAMultiPrimePrivateCrtKey.html">RSAMultiPrimePrivateCrtKey</A> 
<LI><a href = "../../api/java/security/interfaces/RSAPrivateCrtKey.html">RSAPrivateCrtKey</A> 
<LI><a href = "../../api/java/security/interfaces/RSAPrivateKey.html">RSAPrivateKey</A> 
<LI><a href = "../../api/java/security/interfaces/RSAPublicKey.html">RSAPublicKey</A> 
<LI><a href = "../../api/javax/crypto/SecretKey.html">SecretKey</A> 
</UL>
</TD>
</TR>
</TABLE>

<H3>The <code>PublicKey</code> and <code>PrivateKey</code> Interfaces</H3>

<blockquote>

<P>
The <code>PublicKey</code> and <code>PrivateKey</code> interfaces 
(which both extend the <code>Key</code> 
interface) are methodless interfaces,
used for type-safety and type-identification.

</blockquote>

</blockquote>



<H2><a name="KeySpecs">Key Specification Interfaces and Classes</a></H2>

<blockquote>

<P> Key specifications are transparent representations of the key material
that constitutes a key. If the key is stored on a hardware device, its
specification may contain information that helps identify the key on the
device.

<p>A <i>transparent</i> representation of keys means that you can access
each key material value individually, through one of the <code>get</code> 
methods defined 
in the corresponding specification class. For example, <code>DSAPrivateKeySpec</code>
defines <code>getX</code>, <code>getP</code>, <code>getQ</code>, and
<code>getG</code> methods, to access the private key <code>x</code>, 
and the DSA algorithm
parameters used to calculate the key: the prime <code>p</code>, 
the sub-prime <code>q</code>, and the base <code>g</code>.

<p>This representation is contrasted with an <i>opaque</i> representation, 
as defined by the 
<a href = "#Key"><code>Key</code></a> interface, in which
you have no direct access to the key material fields.
In other words, an "opaque" representation gives you limited access to the 
key--just the three methods defined by the <code>Key</code> interface: 
<code>getAlgorithm</code>, <code>getFormat</code>, and <code>getEncoded</code>.

<P> A key may be specified in an algorithm-specific way, or in an
algorithm-independent encoding format (such as ASN.1).
For example, a DSA private key may be specified by its components
<code>x</code>, <code>p</code>, <code>q</code>, and <code>g</code>
(see <a href = "#DSAPrivateKeySpec"><code>DSAPrivateKeySpec</code></a>), or it may be
specified using its DER encoding
(see <a href = "#PKCS8EncodedKeySpec"><code>PKCS8EncodedKeySpec</code></a>).

<p>In the following sections, we discuss the key specification interfaces 
and classes in the <code>java.security.spec</code> package.


<H3><a name="KeySpec">The <code>KeySpec</code> Interface</a></H3>

<blockquote>

<P> This interface contains no methods or constants. Its only purpose
is to group and provide type safety for all key specifications.
All key specifications must implement this interface.

</blockquote>


<H3><a name="DSAPrivateKeySpec">The <code>DSAPrivateKeySpec</code> Class</a></H3>

<blockquote>

This class (which implements the <a href = "#KeySpec"><code>KeySpec</code></a> interface) 
specifies a DSA private key with its associated parameters.
<code>DSAPrivateKeySpec</code> has the following methods:

<blockquote>
<pre>
BigInteger getX()
BigInteger getP()
BigInteger getQ()
BigInteger getG()
</pre>
</blockquote>

These methods return the private key <code>x</code>, and the DSA algorithm
parameters used to calculate the key: the prime <code>p</code>, 
the sub-prime <code>q</code>, and the base <code>g</code>.

</blockquote>


<H3><a name="DSAPublicKeySpec">The <code>DSAPublicKeySpec</code> Class</a></H3>

<blockquote>

This class (which implements the <a href = "#KeySpec"><code>KeySpec</code></a> interface) 
specifies a DSA public key with its associated parameters.
<code>DSAPublicKeySpec</code> has the following methods:

<blockquote>
<pre>
BigInteger getY()
BigInteger getP()
BigInteger getQ()
BigInteger getG()
</pre>
</blockquote>


These methods return the public key <code>y</code>, and the DSA algorithm
parameters used to calculate the key: the prime <code>p</code>, 
the sub-prime <code>q</code>, and the base <code>g</code>.

</blockquote>


<H3><a name="RSAPrivateKeySpec">The <code>RSAPrivateKeySpec</code> Class</a></H3>

<blockquote>

This class (which implements the <a href = "#KeySpec"><code>KeySpec</code></a> interface) 
specifies an RSA private key. <code>RSAPrivateKeySpec</code> has the following methods:

<blockquote>
<pre>
BigInteger getModulus()
BigInteger getPrivateExponent()
</pre>
</blockquote>

These methods return the RSA modulus <code>n</code>
and private exponent <code>d</code> values that constitute
the RSA private key.

</blockquote>


<H3><a name="RSAPrivateCrtKeySpec">The <code>RSAPrivateCrtKeySpec</code> Class</a></H3>

<blockquote>

This class (which extends the 
<a href = "#RSAPrivateKeySpec"><code>RSAPrivateKeySpec</code></a> class)
specifies an RSA private key, as
defined in the PKCS #1 standard, using the
<i>Chinese Remainder Theorem</i> (CRT) information values.
<code>RSAPrivateCrtKeySpec</code> has the following methods (in addition to the 
methods inherited from its superclass <code>RSAPrivateKeySpec</code>):

<blockquote>
<pre>
BigInteger getPublicExponent()
BigInteger getPrimeP()
BigInteger getPrimeQ()
BigInteger getPrimeExponentP()
BigInteger getPrimeExponentQ()
BigInteger getCrtCoefficient()
</pre>
</blockquote>

These methods return the public exponent <code>e</code>
and the CRT information integers:
the prime factor <code>p</code> of the modulus <code>n</code>,
the prime factor <code>q</code> of <code>n</code>, the
exponent <code>d mod (p-1)</code>,
the exponent <code>d mod (q-1)</code>, and the Chinese
Remainder Theorem coefficient <code>(inverse of q) mod p</code>.
   
<p>An RSA private key logically consists of only the modulus
and the private exponent. The presence of the CRT values is
intended for efficiency.

</blockquote>


<H3>
<a name="RSAMultiPrimePrivateCrtKeySpec">
The <code>RSAMultiPrimePrivateCrtKeySpec</code> Class</a></H3>

<blockquote>

This class (which extends the 
<a href = "#RSAPrivateKeySpec"><code>RSAPrivateKeySpec</code></a> class) 
specifies an RSA multi-prime private key, 
as defined in the PKCS#1 v2.1, 
using the Chinese Remainder Theorem (CRT) 
information values. 

<code>RSAMultiPrimePrivateCrtKeySpec</code> 
has the following methods (in addition to the 
methods inherited from its superclass <code>RSAPrivateKeySpec</code>):

<blockquote>
<pre>
BigInteger getPublicExponent()
BigInteger getPrimeP()
BigInteger getPrimeQ()
BigInteger getPrimeExponentP()
BigInteger getPrimeExponentQ()
BigInteger getCrtCoefficient()
RSAOtherPrimeInfo[] getOtherPrimeInfo()
</pre>
</blockquote>

These methods return the public exponent <code>e</code>
and the CRT information integers:
the prime factor <code>p</code> of the modulus <code>n</code>,
the prime factor <code>q</code> of <code>n</code>, the
exponent <code>d mod (p-1)</code>,
the exponent <code>d mod (q-1)</code>, and the Chinese
Remainder Theorem coefficient <code>(inverse of q) mod p</code>.
<P> 
Method <code>getOtherPrimeInfo</code> returns a copy of the  
<code>otherPrimeInfo</code> (defined in 
<A HREF="http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/">PKCS#1 v 2.1</A>) 
or null if there are  
only two prime factors (<code>p</code> and <code>q</code>). 

   
<p>An RSA private key logically consists of only the modulus
and the private exponent. The presence of the CRT values is
intended for efficiency.

</blockquote>


<H3><a name="RSAPublicKeySpec">The <code>RSAPublicKeySpec</code> Class</a></H3>

<blockquote>

This class (which implements the <a href = "#KeySpec"><code>KeySpec</code></a> interface) 
specifies an RSA public key. <code>RSAPublicKeySpec</code> has the following methods:

<blockquote>
<pre>
BigInteger getModulus()
BigInteger getPublicExponent()
</pre>
</blockquote>

These methods return the RSA modulus <code>n</code>
and public exponent <code>e</code> values
that constitute the RSA public key.

</blockquote>



<H3><a name="EncodedKeySpec">The <code>EncodedKeySpec</code> Class</a></H3>

<blockquote>

This abstract class (which implements the <a href = "#KeySpec"><code>KeySpec</code></a>
interface) represents a public or private key in encoded format.
Its <code>getEncoded</code> method returns the encoded key:

<blockquote>
<pre>
abstract byte[] getEncoded();
</pre>
</blockquote>

and its <code>getFormat</code> method returns the name of the encoding 
format:

<blockquote>
<pre>
abstract String getFormat();
</pre>
</blockquote>

<p>See the next sections for the concrete implementations <code>PKCS8EncodedKeySpec</code> and
<code>X509EncodedKeySpec</code>.


<H4><a name="PKCS8EncodedKeySpec">The <code>PKCS8EncodedKeySpec</code> Class</a></H4>

<blockquote>

This class, which is a subclass of <code>EncodedKeySpec</code>, represents the DER encoding 
of a private key, according to the
format specified in the PKCS #8 standard.

Its <code>getEncoded</code> method returns the key bytes, encoded according to
the PKCS #8 standard. Its <code>getFormat</code> method returns the string 
"PKCS#8".

</blockquote>


<H4><a name="X509EncodedKeySpec">The <code>X509EncodedKeySpec</code> Class</a></H4>

<blockquote>

This class, which is a subclass of <code>EncodedKeySpec</code>, represents the DER 
encoding of a public key, according to the format specified 
in the X.509 standard.

Its <code>getEncoded</code> method returns the key bytes, encoded according to
the X.509 standard. Its <code>getFormat</code> method returns the string 
"X.509".

</blockquote>

</blockquote>

</blockquote>




<H2><a name="KeyFactory">The <code>KeyFactory</code> Class</a></H2>

<blockquote>

The <code>KeyFactory</code> class is an <a href = "#Engine">engine class</a> 
designed to provide conversions between opaque cryptographic keys
(of type <a href = "#Key"><code>Key</code></a>) and 
<a href = "#KeySpecs">key specifications</a> (transparent representations 
of the underlying key material).

<P> Key factories are bi-directional. They allow you to build an opaque
key object from a given key specification (key material), or to retrieve
the underlying key material of a key object in a suitable format.

<P> Multiple compatible key specifications can exist for the same key.
For example, a DSA public key may be specified by its components
<code>y</code>, <code>p</code>, <code>q</code>, and <code>g</code>
(see <a href = "#DSAPublicKeySpec"><code>DSAPublicKeySpec</code></a>), or it may be
specified using its DER encoding according to the X.509 standard
(see <a href = "#X509EncodedKeySpec"><code>X509EncodedKeySpec</code></a>).

<p>A key factory can be used to translate
between compatible key specifications.
Key parsing can be achieved
through translation between compatible key specifications, e.g., when you
translate from <code>X509EncodedKeySpec</code> to <code>DSAPublicKeySpec</code>, 
you basically 
parse the encoded key into its components. For an example, see 
the end of the 
<a href = "#KeyFactoryEx">Generating/Verifying Signatures Using Key 
Specifications and <code>KeyFactory</code></a> section.


<H3>Creating a <code>KeyFactory</code> Object</H3>

<blockquote>

<P>
As with all engine classes, the 
way to get a <code>KeyFactory</code> object for a particular type of key
algorithm is to call the <code>getInstance</code>
static factory method on the <code>KeyFactory</code> class:
<P>

<blockquote>
<pre>
static KeyFactory getInstance(String algorithm) 
</pre>
</blockquote>

<blockquote>
<hr>
<b>Note:</B> The algorithm name is not case-sensitive.
<hr>
</blockquote>


A caller may optionally specify the name of a provider or the 
<code>Provider</code> class, which will 
guarantee that the implementation of the key factory
requested is from the named provider.


<blockquote>
<pre>
static KeyFactory getInstance(String algorithm, String provider)
static KeyFactory getInstance(String algorithm, Provider provider)
</pre>
</blockquote>

</blockquote>

<H3>Converting Between a Key Specification and a Key Object</H3>

<blockquote>

<p>If you have a key specification for a public key, you can
obtain an opaque <code>PublicKey</code> object from the specification by using
the <code>generatePublic</code> method:

<blockquote>
<pre>
PublicKey generatePublic(KeySpec keySpec)
</pre>
</blockquote>

<p>Similarly, if you have a key specification for a private key, you can
obtain an opaque <code>PrivateKey</code> object from the specification by using
the <code>generatePrivate</code> method:

<blockquote>
<pre>
PrivateKey generatePrivate(KeySpec keySpec)
</pre>
</blockquote>

</blockquote>


<H3>Converting Between a Key Object and a Key Specification</H3>

<blockquote>

<p>If you have a <code>Key</code> object, you can get a corresponding key
specification object by calling the <code>getKeySpec</code> method:

<blockquote>
<pre>
KeySpec getKeySpec(Key key, Class keySpec)
</pre>
</blockquote>

<code>keySpec</code> identifies the specification class in which 
the key material should be returned. It could, for example, be
<code>DSAPublicKeySpec.class</code>, to indicate that the
key material should be returned in an instance of the 
<a href = "#DSAPublicKeySpec"><code>DSAPublicKeySpec</code></a> class.

<p>
Please see the <a href = "#KeyFactoryEx">Examples</a> section for more details.


</blockquote>

</blockquote>



<H2><a name="CertificateFactory">The <code>CertificateFactory</code> Class</a></H2>

<blockquote>

The <code>CertificateFactory</code> class is an <a href = "#Engine">engine class</a> 
that defines the functionality of a certificate factory, which is
used to generate certificate and certificate revocation list (CRL) objects
from their encodings.

<p>A certificate factory for X.509 must return certificates that are an
instance of <code>java.security.cert.X509Certificate</code>, and CRLs
that are an instance of <code>java.security.cert.X509CRL</code>.


<H3>Creating a <code>CertificateFactory</code> Object</H3>

<blockquote>

<P>
As with all engine classes, the 
way to get a <code>CertificateFactory</code> object for a particular certificate or CRL
type is to call the <code>getInstance</code>
static factory method on the <code>CertificateFactory</code> class:
<P>

<blockquote>
<pre>
static CertificateFactory getInstance(String type) 
</pre>
</blockquote>

<blockquote>
<hr>
<B>Note:</B> The type name is not case-sensitive.
<hr>
</blockquote>

A caller may optionally specify the name of a provider 
or the <code>Provider</code> class, which will 
guarantee that the implementation of the certificate factory
requested is from the named provider.


<blockquote>
<pre>
static CertificateFactory getInstance(String type, String provider)

static CertificateFactory getInstance(String type, Provider provider)
</pre>
</blockquote>

</blockquote>


<H3>Generating Certificate Objects</H3>

<blockquote>

To generate a certificate object and initialize it with
the data read from an input stream, use the
<code>generateCertificate</code> method:

<blockquote>
<pre>
final Certificate generateCertificate(InputStream inStream)
</pre>
</blockquote>

To return a (possibly empty) collection view of the certificates read
from a given input stream, use the
<code>generateCertificates</code> method:

<blockquote>
<pre>
final Collection generateCertificates(InputStream inStream)
</pre>
</blockquote>

</blockquote>

<H3>Generating CRL Objects</H3>

<blockquote>

To generate a certificate revocation list (CRL) object and initialize it with
the data read from an input stream, use the
<code>generateCRL</code> method:

<blockquote>
<pre>
final CRL generateCRL(InputStream inStream)
</pre>
</blockquote>

To return a (possibly empty) collection view of the CRLs read
from a given input stream, use the
<code>generateCRLs</code> method:

<blockquote>
<pre>
final Collection generateCRLs(InputStream inStream)
</pre>
</blockquote>

</blockquote>




<H3>Generating <code>CertPath</code> Objects</H3>

<blockquote>

To generate a <code>CertPath</code> object and 
initialize it with data read from an input stream, 
use one of the following <code>generateCertPath</code> methods 
(with or without specifying the encoding to be used for the data):    

<blockquote>
<pre>
final CertPath generateCertPath(InputStream inStream)

final CertPath generateCertPath(InputStream inStream, 
                                String encoding)
</pre>
</blockquote>

To generate a <code>CertPath</code> object and 
initialize it with a list of certificates, 
use the following method:

<blockquote>
<pre>
final CertPath generateCertPath(List certificates)
</pre>
</blockquote>

To retrieve a list of the <code>CertPath</code>  
encodings supported by this certificate factory, 
you can call the <code>getCertPathEncodings</code> method:

<blockquote>
<pre>
final Iterator getCertPathEncodings()
</pre>
</blockquote>

The default encoding will be listed first.

</blockquote>

</blockquote>

<H2><a name="KeyPair">The <code>KeyPair</code> Class</a></H2>

<blockquote>

<P>
The <code>KeyPair</code> class is a simple holder for a key pair (a public key and a
private key). It has two public methods, one for returning the private
key, and the other for returning the public key:

<blockquote>
<pre>
PrivateKey getPrivate()
PublicKey getPublic()
</pre>
</blockquote>

</blockquote>



<H2><a name="KPG">The <code>KeyPairGenerator</code> Class</a></H2>

<blockquote>

<P>
The <code>KeyPairGenerator</code> class is an <a href = "#Engine">engine class</a> 
used to generate pairs of public and private keys. 

<P>
There are two ways to generate a key pair: in an 
algorithm-independent
manner, and in an algorithm-specific manner. The only difference
between the two is the initialization of the object. 

<P>
Please see the <a href = "#KPGEx">Examples</a> section for examples
of calls to the methods documented below.

<H3>Creating a <code>KeyPairGenerator</code></H3>

<blockquote>

<P>
All key pair generation starts with a <code>KeyPairGenerator</code>. This generation 
is done using one of the factory methods on <code>KeyPairGenerator</code>:
<P>

<blockquote>
<pre>
static KeyPairGenerator getInstance(String algorithm)
static KeyPairGenerator getInstance(String algorithm, 
                                    String provider)
static KeyPairGenerator getInstance(String algorithm, 
                                    Provider provider)
</pre>
</blockquote>

<blockquote>
<hr><B>Note:</B> The algorithm name is not case-sensitive. 
<hr>
</blockquote>

</blockquote>


<H3>Initializing a <code>KeyPairGenerator</code></H3>

<blockquote>

A key pair generator for a particular algorithm
creates a public/private key pair that can be used with
this algorithm. 
It also associates algorithm-specific parameters with 
each of the generated keys.

<P>
A key pair generator needs to be initialized before it can generate
keys. In most cases,
algorithm-independent initialization is sufficient. But in other
cases, algorithm-specific initialization is used.

<H4>Algorithm-Independent Initialization</H4>

<P>
All key pair generators share the concepts of a keysize and a
source of randomness. The keysize is 
interpreted differently for different algorithms.
For example, in the case of the DSA algorithm, the keysize
corresponds to the length of the modulus.
(See <a href = "#AppB">Appendix B: Algorithms</a> for 
information about the keysizes for specific algorithms.) 

<p>An <code>initialize</code> method 
takes two universally shared types of arguments:

<blockquote>
<pre>
void initialize(int keysize, SecureRandom random)
</pre>
</blockquote>

Another <code>initialize</code> method 
takes only a <code>keysize</code> 
argument; it uses a system-provided source of randomness:

<blockquote>
<pre>
void initialize(int keysize)
</pre>
</blockquote>

<P>
Since no other parameters are specified when you call the above
algorithm-independent <code>initialize</code>
methods, it is up to the provider what to do about the algorithm-specific
parameters (if any) to be associated with each of the keys.

<p>If the algorithm is a "DSA" algorithm, and the modulus size (keysize)
is 512, 768, or 1024, then the "SUN" provider uses a set of precomputed
values for the <code>p</code>, <code>q</code>, and 
<code>g</code> parameters. If the modulus size is
not one of the above values, the "SUN" provider creates a new
set of parameters. Other providers might have
precomputed parameter sets for more than just the three modulus sizes
mentioned above. Still others might not have a list of precomputed 
parameters at all and instead always create new parameter sets. 


<H4>Algorithm-Specific Initialization</H4>

<p>For situations where a set of algorithm-specific parameters already
exists (such as "community parameters" in DSA),
there are two <code>initialize</code> methods that have an 
<a href = "#AlgorithmParameterSpec"><code>AlgorithmParameterSpec</code></a> argument.
One also has a <code>SecureRandom</code> argument, while the source of
randomness is system-provided for the other:

<blockquote>
<pre>
void initialize(AlgorithmParameterSpec params,
                SecureRandom random)

void initialize(AlgorithmParameterSpec params)
</pre>
</blockquote>

See the <a href = "#KPGEx">Examples</a> section for more details.

</blockquote>


<H3>Generating a Key Pair</H3>

<blockquote>

<P>
The procedure for generating a key pair is always the same, regardless 
of initialization (and of the algorithm). You always call the following 
method from <code>KeyPairGenerator</code>:

<blockquote>
<pre>
KeyPair generateKeyPair()
</pre>
</blockquote>

Multiple calls to <code>generateKeyPair</code> will yield different key pairs.

</blockquote>

</blockquote>



<H2><a name="KeyManagement">Key Management</a></H2>

<blockquote>

A database called a "keystore" can be used to 
manage a repository of keys and certificates. 
(A <i>certificate</i> is a digitally signed statement
from one entity, saying that the public key of some other entity has a 
particular value.)

<H3><a name="KeystoreLocation">Keystore Location</a></H3>

      <blockquote>
        <p>The keystore is by default stored in a file 
          named <code>.keystore</code> in the user's home directory, as determined by the 
          &quot;user.home&quot; system property. On Solaris systems &quot;user.home&quot; 
          defaults
          to the user's home directory. On Win32 systems, given user name 
          <i>uName</i>,
          &quot;user.home&quot; defaults to: 
        <blockquote>
          <ul>
              <li><tt>C:\Winnt\Profiles\uName</tt> on multi-user Windows NT systems
              <li><tt>C:\Windows\Profiles\uName</tt> on multi-user Windows 95/98/2000 systems
              <li><tt>C:\Windows on single-user</tt> Windows 95/98/2000 systems
          </ul> 
        </blockquote> 
      </blockquote>

<H3><a name=KeystoreImplementation>Keystore Implementation</a></H3>

<blockquote>

The <a href = "#KeyStore"><code>KeyStore</code></a> class supplies
well-defined interfaces to access and modify the information
in a keystore. It is possible for there to be
multiple different concrete implementations, where each 
implementation is that for a particular <i>type</i> of keystore.

<p>Currently, there are two command-line tools that make use of <code>KeyStore</code>:
<b><code>keytool</code></b> and <b><code>jarsigner</code></b>, 
and also a GUI-based tool named <b><code>policytool</code></b>. 
It is also used by the <code>Policy</code> reference
implementation when it processes policy files specifying the
permissions (allowed accesses to system resources) to be granted
to code from various sources.
Since <code>KeyStore</code>
is publicly available, SDK users can write additional security applications
that use it.
<a name="JceKeysotre"></a>
<p>There is a built-in default implementation, provided by 
Sun Microsystems. It implements the keystore as a file, utilizing
a proprietary keystore type (format) named "JKS". 
It protects each private key with its individual password, and also protects 
the integrity of the entire keystore with a
(possibly different) password.

<p>Keystore implementations are provider-based. More specifically, 
the application interfaces supplied by <code>KeyStore</code> are
implemented in terms of a "Service Provider Interface" (SPI).
That is, there is a corresponding abstract <code>KeystoreSpi</code> class, 
also in the <code>java.security</code> package, which defines the SPI 
methods that "providers" must implement.
(The term "provider" refers to a package or a set of packages that supply
a concrete implementation of a subset of services that can be accessed
by the Java 2 SDK Security API.)
Therefore, to provide a keystore implementation clients must implement a
"provider" and supply a <code>KeystoreSpi</code> subclass implementation, as described in
<a href="HowToImplAProvider.html">How to Implement a 
Provider for the Java Cryptography Architecture</a>.

<p>Applications can choose different <i>types</i> of keystore implementations
from different providers, using the <code>getInstance</code> factory method 
in the <code>KeyStore</code> class.
A keystore type defines the storage and data format of the keystore
information, and the algorithms used to
protect private keys in the keystore and the integrity of the keystore
itself. Keystore implementations of different types are not compatible. 

<p>The default keystore type is "jks" (the proprietary type of the
keystore implementation provided by the "SUN" provider). This is specified by
the following line in the security properties file:

<blockquote>
<pre>
keystore.type=jks
</pre>
</blockquote>

To have tools and other applications use a keystore implementation 
other than the default keystore, you can change that line to specify a different 
keystore type. Another solution would be to let users of your tools
and applications specify a keystore type, and pass that value to the
<code>getInstance</code> method of KeyStore. 

<p>An example of the former approach is the following: 
If you have a provider package that supplies a
keystore implementation for a keystore type called <code>pkcs12</code>,
change the line to

<blockquote>
<pre>
keystore.type=pkcs12
</pre>
</blockquote>

<blockquote>
<hr>
<b>Note:</B> Keystore type designations are not case-sensitive. For example,
"JKS" would be considered the same as "jks".
<hr>
</blockquote>

</blockquote>


<H3><a name="KeyStore">The <code>KeyStore</code> Class</a></H3>

<blockquote>

The <code>KeyStore</code> class is an <a href = "#Engine">engine class</a> 
that supplies well-defined interfaces to access and modify the information
in a keystore.

<p>This class represents an in-memory collection of keys and certificates.
<code>KeyStore</code> manages two types of entries:


<blockquote>
<dl>

<dt><b>Key Entry</b></dt>
<dd>
<p>This type of keystore entry holds very sensitive cryptographic key
information, which is stored in a protected format to prevent unauthorized
access.
Typically, a key stored in this type of entry is a secret key, or a
private key accompanied by the certificate chain authenticating the
corresponding public key.

<p>Private keys and certificate chains are used by a given entity for
self-authentication using digital signatures. For example, software
distribution organizations digitally sign JAR files as part of releasing
and/or licensing software.<p>

<dt><b>Trusted Certificate Entry</b></dt>
<dd>
<p>This type of entry contains a single public key certificate belonging to
another party. It is called a <i>trusted certificate</i> because the
keystore owner trusts that the public key in the certificate indeed belongs
to the identity identified by the <i>subject</i> (owner) of the
certificate. 

<p>This type of entry can be used to authenticate other parties.

</dl>
</blockquote>

Each entry in a keystore is identified by an "alias" string. In the
case of private keys and their associated certificate chains, these strings
distinguish among the different ways in which the entity may authenticate
itself. For example, the entity may authenticate itself using different
certificate authorities, or using different public key algorithms.

<p>Whether keystores are persistent, and the mechanisms used by the
keystore if it is persistent, are not specified here. This convention allows
use of a variety of techniques for protecting sensitive (e.g., private or
secret) keys. Smart cards or other integrated cryptographic engines
(SafeKeyper) are one option, and simpler mechanisms such as files may also
be used (in a variety of formats).

<p>The main <code>KeyStore</code> methods are described below.


<H3>Creating a <code>KeyStore</code> Object</H3>

<blockquote>

<P>
As with all engine classes, the 
way to get a <code>KeyStore</code> object is to call the <code>getInstance</code>
static factory method on the <code>KeyStore</code> class:
<P>

<blockquote>
<pre>
static KeyStore getInstance(String type) 
</pre>
</blockquote>

<p>
A caller may optionally specify the name of a provider or the 
<code>Provider</code> class, which will 
guarantee that the implementation of the type requested is from the
named provider:
<P>

<blockquote>
<pre>
static KeyStore getInstance(String type, String provider)
static KeyStore getInstance(String type, Provider provider)
</pre>
</blockquote>

</blockquote>


<H3>Loading a Particular Keystore into Memory</H3>

<blockquote>

Before a <code>KeyStore</code> object can be used, the actual keystore data
must be loaded into memory via the <code>load</code> method:

<blockquote>
<pre>
final void load(InputStream stream, char[] password)
</pre>
</blockquote>

The optional password is used to check the integrity of the keystore
data. If no password is supplied, no integrity check
is performed.

<p>To create an empty keystore, you pass <code>null</code>
as the <code>InputStream</code> argument to the <code>load</code> method.

</blockquote>


<H3>Getting a List of the Keystore Aliases</H3>

<blockquote>

<p>All keystore entries are accessed via unique <i>aliases</i>. 
The <code>aliases</code> method returns an enumeration of the alias names
in the keystore:

<blockquote>
<pre>
final Enumeration aliases()
</pre>
</blockquote>

</blockquote>


<H3>Determining Keystore Entry Types</H3>

<blockquote>

As stated in <a href = "#KeyStore">The <code>KeyStore</code> Class</a>, there are 
two different types of entries in a keystore.

<p>The following methods determine whether the entry specified by the
given alias is a key/certificate or a trusted certificate entry,
respectively:

<blockquote>
<pre>
final boolean isKeyEntry(String alias)
final boolean isCertificateEntry(String alias)
</pre>
</blockquote>
</blockquote>


<H3>Adding/Setting/Deleting Keystore Entries</H3>

<blockquote>

The <code>setCertificateEntry</code> method assigns a certificate to a specified
alias:

<blockquote>
<pre>
final void setCertificateEntry(String alias, Certificate cert)
</pre>
</blockquote>

If <code>alias</code> doesn't exist, a trusted certificate entry with
that alias is created. If <code>alias</code> exists and identifies 
a trusted certificate entry, the certificate associated
with it is replaced by <code>cert</code>.

<p>The <code>setKeyEntry</code> methods add (if <code>alias</code> doesn't 
yet exist) or set key entries:

<blockquote>
<pre>
final void setKeyEntry(String alias,
                       Key key, 
                       char[] password,
                       Certificate[] chain)

final void setKeyEntry(String alias,
                       byte[] key,
                       Certificate[] chain)
</pre>
</blockquote>
In the method with <code>key</code> as a byte array, it is the bytes for a
key in protected format.  For
example, in the keystore implementation supplied by the "SUN" provider, 
the <code>key</code> byte array is expected to contain a protected private
key, encoded as an <code>EncryptedPrivateKeyInfo</code> as defined in the 
PKCS #8 standard. In the other method, the <code>password</code> is
the password used to protect the key.

<p>The <code>deleteEntry</code> method deletes an entry:

<blockquote>
<pre>
final void deleteEntry(String alias)
</pre>
</blockquote>
</blockquote>


<H3>Getting Information from the Keystore</H3>

<blockquote>

The <code>getKey</code> method returns the key associated with the 
given alias. The key is recovered using the given password:


<blockquote>
<pre>
final Key getKey(String alias, char[] password)
</pre>
</blockquote>

The following methods return the certificate, or certificate chain,
respectively, associated with the given alias:

<blockquote>
<pre>
final Certificate getCertificate(String alias)
final Certificate[] getCertificateChain(String alias)
</pre>
</blockquote>

You can determine the name (<code>alias</code>) of the first entry whose
certificate matches a given certificate via the following:

<blockquote>
<pre>
final String getCertificateAlias(Certificate cert)
</pre>
</blockquote>
</blockquote>



<H3>Saving the KeyStore</H3>

<blockquote>

The in-memory keystore can be saved via the <code>store</code> method:

<blockquote>
<pre>
final void store(OutputStream stream, char[] password)
</pre>
</blockquote>

The password is used to calculate an integrity
checksum of the keystore data, which is appended to the
keystore data.

</blockquote>

</blockquote>

</blockquote>




<H2><a name="SecureRandom"> The <code>SecureRandom</code> Class</a></H2>

<blockquote>

<P>
The <code>SecureRandom</code> class is an <a href = "#Engine">engine class</a> 
that provides the functionality
of a random number generator. 

<H3>Creating a <code>SecureRandom</code> Object</H3>

<blockquote>

As with all engine classes, the 
way to get a <code>SecureRandom</code> object is to call the <code>getInstance</code>
static factory method on the <code>SecureRandom</code> class:
<P>

<blockquote>
<pre>
static SecureRandom getInstance(String algorithm)
</pre>
</blockquote>
<p>A caller may optionally specify the name of a provider or the 
<code>Provider</code> class, which will 
guarantee that the implementation of the random number 
generation (RNG) algorithm requested is from the
named provider:

<blockquote>
<pre>
static final SecureRandom getInstance(String algorithm,
                                      String provider)
static final SecureRandom getInstance(String algorithm,
                                      Provider provider)
</pre>
</blockquote>
</blockquote>


<H3>Seeding or Re-Seeding the <code>SecureRandom</code> Object</H3>

<blockquote>

<p>The <code>SecureRandom</code> implementation attempts to completely
randomize the internal state of the generator itself unless
the caller follows the call to a <code>getInstance</code> method
with a call to one of the <code>setSeed</code> methods:
<blockquote>
<pre>
synchronized public void setSeed(byte[] seed)
public void setSeed(long seed)
</pre>
</blockquote>

Once the <code>SecureRandom</code> object has 
been seeded, it will produce bits as random
as the original seeds.

<p>At any time a <code>SecureRandom</code> object may be re-seeded using one of the
<code>setSeed</code> methods. The given seed supplements, 
rather than replaces, the existing seed; therefore, repeated calls 
are guaranteed never to reduce randomness.

</blockquote>


<H3>Using a <code>SecureRandom</code> Object</H3>

<blockquote>

<P>
To get random bytes, a caller simply passes an array of any length,
which is then filled with random bytes:


<blockquote>
<pre>
synchronized public void nextBytes(byte[] bytes)
</pre>
</blockquote>

</blockquote>



<H3>Generating Seed Bytes</H3>

<blockquote>

If desired, it is possible to invoke the <code>generateSeed</code> method
to generate a given number of seed bytes (to seed other random number
generators, for example):

<blockquote>
<pre>
byte[] generateSeed(int numBytes)
</pre>
</blockquote>

</blockquote>

</blockquote>


  <ul>
    <li>
      <h2><a name="CipherClass">The Cipher Class</a></h2>
      <blockquote>
        <p>The <code>Cipher</code> class provides the functionality of
a cryptographic cipher used for encryption and decryption. It forms the
core of the JCE framework. </p>
        <h4>Creating a Cipher Object</h4>
        <blockquote>
          <p>Like other engine classes in the API, <code>Cipher</code>
objects are created using the <code>getInstance</code> factory methods
of the <code>Cipher</code> class. A factory method is a static method
that returns an instance of a class, in this case, an instance of <code>Cipher</code>,
which implements a requested <i>transformation</i>. </p>
          <p>To create a <code>Cipher</code> object, you must specify
the transformation name. You may also specify which provider you want
to supply the implementation of the requested transformation: </p>
          <pre>    <br>    public static Cipher getInstance(String transformation);<br>    <br>    public static Cipher getInstance(String transformation,<br>                                     String provider);<br></pre>
          <p>If just a transformation name is specified, the system
will determine if there is an implementation of the requested
transformation available in the environment, and if there is more than
one, if there is a preferred one. </p>
          <p>If both a transformation name and a package provider are
specified, the system will determine if there is an implementation of
the requested transformation in the package requested, and throw an
exception if there is not. </p>
          <p><a name="trans">A transformation is a string that
describes the operation (or set of operations) to be performed on the
given input, to produce some output. A transformation always includes
the name of a cryptographic algorithm (e.g., <code>DES</code>), and
may be followed by a mode and padding scheme. </a></p>
          <p><a name="trans">A transformation is of the form: </a></p>
          <p><a name="trans"> </a></p>
          <ul>
            <a name="trans"> <li>"<i>algorithm/mode/padding</i>" or
              <p></p>
            </li>
            <li>"<i>algorithm</i>" </li>
            </a>
          </ul>
          <a name="trans"> </a>
          <p><a name="trans">For example, the following are valid
transformations: </a></p>
          <p></p>
          <pre><a name="trans">    "<i>DES/CBC/PKCS5Padding</i>"<br><br>    "<i>DES</i>"<br></a></pre>
          <a name="trans"> </a>
          <p><a name="trans">If no mode or padding is specified,
provider-specific default values for the mode and padding scheme are
used. For example, the SunJCE provider uses <code>ECB</code> as the
default mode, and <code>PKCS5Padding</code> as the default padding
scheme for <code>DES</code>, <code>DES-EDE</code> and <code>Blowfish</code>
ciphers. This means that in the case of the SunJCE provider, </a></p>
          <p></p>
          <pre><a name="trans">    Cipher c1 = Cipher.getInstance("<i>DES/ECB/PKCS5Padding</i>");<br></a></pre>
          <a name="trans"> </a>
          <p><a name="trans">and </a></p>
          <p></p>
          <pre><a name="trans">    Cipher c1 = Cipher.getInstance("<i>DES</i>");<br></a></pre>
          <a name="trans"> </a>
          <p><a name="trans">are equivalent statements. </a></p>
          <p><a name="trans">When requesting a block cipher in stream
cipher mode (e.g., <code>DES</code> in <code>CFB</code> or <code>OFB</code>
mode), you may optionally specify the number of bits to be processed at
a time, by appending this number to the mode name as shown in the "<i>DES/CFB8/NoPadding</i>"
and "<i>DES/OFB32/PKCS5Padding</i>" transformations. If no such number
is specified, a provider-specific default is used. (For example, the
SunJCE provider uses a default of 64 bits.) </a></p>
          <p><a href="#AppA">Appendix A</a> of this document contains a
list of standard names that can be used to specify the algorithm name,
mode, and padding scheme components of a transformation. </p>
          <p>The objects returned by factory methods are uninitialized,
and must be initialized before they become usable. </p>
        </blockquote>
        <h4><a name="InitaCipher">Initializing a Cipher Object</a></h4>
        <blockquote>
          <p>A Cipher object obtained via <code>getInstance</code>
must be initialized for one of four modes, which are defined as final
integer constants in the <code>Cipher</code> class. The modes can be
referenced by their symbolic names, which are shown below along with a
description of the purpose of each mode: </p>
          <p> </p>
          <ul>
            <li>ENCRYPT_MODE
              <p> </p>
              <blockquote>Encryption of data. </blockquote>
            </li>
            <li>DECRYPT_MODE
              <p> </p>
              <blockquote>Decryption of data. </blockquote>
            </li>
            <li>WRAP_MODE
              <p> </p>
              <blockquote>Wrapping a Key into bytes so that the key can
be securely transported. </blockquote>
            </li>
            <li>UNWRAP_MODE
              <p> </p>
              <blockquote>Unwrapping of a previously wrapped key into a
                <code>java.security.Key</code> object. </blockquote>
            </li>
          </ul>
          <p>Each of the Cipher initialization methods takes a mode
parameter (<code>opmode</code>), and initializes the Cipher object for
that mode. Other parameters include the key (<code>key</code>) or
certificate containing the key (<code>certificate</code>), algorithm
parameters (<code>params</code>), and a source of randomness (<code>random</code>).
          </p>
          <p>To initialize a Cipher object, call one of the following <code>init</code>
methods: </p>
          <pre>    public void init(int opmode, Key key);<br><br>    public void init(int opmode, Certificate certificate)<br><br>    public void init(int opmode, Key key, <br>                     SecureRandom random);<br><br>    public void init(int opmode, Certificate certificate, <br>                     SecureRandom random)<br><br>    public void init(int opmode, Key key,<br>                     AlgorithmParameterSpec params);<br><br>    public void init(int opmode, Key key,<br>                     AlgorithmParameterSpec params,<br>                     SecureRandom random);<br><br>    public void init(int opmode, Key key,<br>                     AlgorithmParameters params)<br><br>    public void init(int opmode, Key key,<br>                     AlgorithmParameters params,<br>                     SecureRandom random)<br></pre>
          <p>If a Cipher object that requires parameters (e.g., an
initialization vector) is initialized for encryption, and no parameters
are supplied to the <code>init</code> method, the underlying cipher
implementation is supposed to supply the required parameters itself,
either by generating random parameters or by using a default,
provider-specific set of parameters. </p>
          <p>However, if a Cipher object that requires parameters is
initialized for decryption, and no parameters are supplied to the <code>init</code>
method, an <code>InvalidKeyException</code> or <code>InvalidAlgorithmParameterException</code>
exception will be raised, depending on the <code>init</code> method
that has been used. </p>
          <p>See the section about <a href="#ManagingParameters">Managing
Algorithm Parameters</a> for more details. </p>
          <p>The same parameters that were used for encryption must be
used for decryption. </p>
          <p>Note that when a Cipher object is initialized, it loses
all previously-acquired state. In other words, initializing a Cipher is
equivalent to creating a new instance of that Cipher, and initializing
it. For example, if a Cipher is first initialized for decryption with a
given key, and then initialized for encryption, it will lose any state
acquired while in decryption mode. </p>
        </blockquote>
        <h4><a name="EncrDecr">Encrypting and Decrypting Data</a></h4>
        <blockquote>
          <p>Data can be encrypted or decrypted in one step (<i>single-part
operation</i>) or in multiple steps (<i>multiple-part operation</i>). A
multiple-part operation is useful if you do not know in advance how
long the data is going to be, or if the data is too long to be stored
in memory all at once. </p>
          <p>To encrypt or decrypt data in a single step, call one of
the <code>doFinal</code> methods: </p>
          <pre>    public byte[] doFinal(byte[] input);<br><br>    public byte[] doFinal(byte[] input, int inputOffset,<br>                          int inputLen);<br><br>    public int doFinal(byte[] input, int inputOffset, <br>                       int inputLen, byte[] output);<br><br>    public int doFinal(byte[] input, int inputOffset, <br>                       int inputLen, byte[] output, int outputOffset)<br></pre>
          <p>To encrypt or decrypt data in multiple steps, call one of
the <code>update</code> methods: </p>
          <pre>    public byte[] update(byte[] input);<br><br>    public byte[] update(byte[] input, int inputOffset, int inputLen);<br><br>    public int update(byte[] input, int inputOffset, int inputLen,<br>                      byte[] output);<br><br>    public int update(byte[] input, int inputOffset, int inputLen,<br>                      byte[] output, int outputOffset)<br></pre>
          <p>A multiple-part operation must be terminated by one of the
above <code>doFinal</code> methods (if there is still some input data
left for the last step), or by one of the following <code>doFinal</code>
methods (if there is no input data left for the last step): </p>
          <pre>    public byte[] doFinal();<br><br>    public int doFinal(byte[] output, int outputOffset);<br></pre>
          <p>All the <code>doFinal</code> methods take care of any
necessary padding (or unpadding), if padding (or unpadding) has been
requested as part of the specified transformation. </p>
          <p>A call to <code>doFinal</code> resets the Cipher object
to the state it was in when initialized via a call to <code>init</code>.
That is, the Cipher object is reset and available to encrypt or decrypt
(depending on the operation mode that was specified in the call to <code>init</code>)
more data. </p>
        </blockquote>
        <h4><a name="WrapUnwrap">Wrapping and Unwrapping Keys</a></h4>
        <blockquote>
          <p>Wrapping a key enables secure transfer of the key from one
place to another. </p>
          <p>The <code>wrap/unwrap</code> API makes it more convenient
to write code since it works with key objects directly. These methods
also enable the possibility of secure transfer of hardware-based keys. </p>
          <p>To <b>wrap</b> a Key, first initialize the Cipher object
for WRAP_MODE, and then call the following: </p>
          <pre>    public final byte[] wrap(Key key);<br></pre>
          <p>If you are supplying the wrapped key bytes (the result of
calling <code>wrap</code>) to someone else who will unwrap them, be
sure to also send additional information the recipient will need in
order to do the <code>unwrap</code>: </p>
          <p> </p>
          <ol>
            <li>the name of the key algorithm, and
              <p></p>
            </li>
            <li>the type of the wrapped key (one of <code>Cipher.SECRET_KEY</code>,
              <code>Cipher.PRIVATE_KEY</code>, or <code>Cipher.PUBLIC_KEY</code>).
            </li>
          </ol>
          <p>The key algorithm name can be determined by calling the <code>getAlgorithm</code>
method from the Key interface: </p>
          <pre>    public String getAlgorithm();<br></pre>
          <p>To <b>unwrap</b> the bytes returned by a previous call to
          <code>wrap</code>, first initialize a Cipher object for
UNWRAP_MODE, then call the following: </p>
          <pre>    public final Key unwrap(byte[] wrappedKey,<br>                            String wrappedKeyAlgorithm,<br>                            int wrappedKeyType));<br></pre>
          <p>Here, <code>wrappedKey</code> is the bytes returned from
the previous call to wrap, <code>wrappedKeyAlgorithm</code> is the
algorithm associated with the wrapped key, and <code>wrappedKeyType</code>
is the type of the wrapped key. This must be one of <code>Cipher.SECRET_KEY</code>,
          <code>Cipher.PRIVATE_KEY</code>, or <code>Cipher.PUBLIC_KEY</code>.
          </p>
        </blockquote>
        <h4><a name="ManagingParameters">Managing Algorithm Parameters</a></h4>
        <blockquote>
          <p>The parameters being used by the underlying Cipher
implementation, which were either explicitly passed to the <code>init</code>
method by the application or generated by the underlying implementation
itself, can be retrieved from the Cipher object by calling its <code>getParameters</code>
method, which returns the parameters as a <code>java.security.AlgorithmParameters</code>
object (or <code>null</code> if no parameters are being used). If the
parameter is an initialization vector (IV), it can also be retrieved by
calling the <code>getIV</code> method. </p>
          <p>In the following example, a Cipher object implementing
password-based encryption is initialized with just a key and no
parameters. However, the selected algorithm for password-based
encryption requires two parameters - a <i>salt</i> and an <i>iteration
count</i>. Those will be generated by the underlying algorithm
implementation itself. The application can retrieve the generated
parameters from the Cipher object as follows: </p>
          <pre>    import javax.crypto.*;<br>    import java.security.AlgorithmParameters;<br><br>    // get cipher object for password-based encryption<br>    Cipher c = Cipher.getInstance("PBEWithMD5AndDES");<br><br>    // initialize cipher for encryption, without supplying<br>    // any parameters. Here, "myKey" is assumed to refer <br>    // to an already-generated key.<br>    c.init(Cipher.ENCRYPT_MODE, myKey);<br> <br>    // encrypt some data and store away ciphertext<br>    // for later decryption<br>    byte[] cipherText = c.doFinal("This is just an example".getBytes());<br><br>    // retrieve parameters generated by underlying cipher<br>    // implementation<br>    AlgorithmParameters algParams = c.getParameters();<br><br>    // get parameter encoding and store it away<br>    byte[] encodedAlgParams = algParams.getEncoded();<br></pre>
          <p>The same parameters that were used for encryption must be
used for decryption. They can be instantiated from their encoding and
used to initialize the corresponding Cipher object for decryption, as
follows: </p>
          <pre>    import javax.crypto.*;<br>    import java.security.AlgorithmParameters;<br><br>    // get parameter object for password-based encryption<br>    AlgorithmParameters algParams;<br>    algParams = <br>      AlgorithmParameters.getInstance("PBEWithMD5AndDES");<br><br>    // initialize with parameter encoding from above<br>    algParams.init(encodedAlgParams);<br><br>    // get cipher object for password-based encryption<br>    Cipher c = Cipher.getInstance("PBEWithMD5AndDES");<br><br>    // initialize cipher for decryption, using one of the <br>    // init() methods that takes an AlgorithmParameters <br>    // object, and pass it the algParams object from above<br>    c.init(Cipher.DECRYPT_MODE, myKey, algParams);<br></pre>
          <p>If you did not specify any parameters when you initialized
a Cipher object, and you are not sure whether or not the underlying
implementation uses any parameters, you can find out by simply calling
the <code>getParameters</code> method of your Cipher object and
checking the value returned. A return value of <code>null</code>
indicates that no parameters were used. </p>
          <p>The following cipher algorithms implemented by the SunJCE
provider use parameters: </p>
          <p> </p>
          <ul>
            <li>DES, DES-EDE, and Blowfish, when used in feedback
(i.e., CBC, CFB, OFB, or PCBC) mode, use an initialization vector (IV).
The <code>javax.crypto.spec.IvParameterSpec</code> class can be used
to initialize a Cipher object with a given IV.
              <p></p>
            </li>
            <li>PBEWithMD5AndDES uses a set of parameters, comprising a
salt and an iteration count. The <code>javax.crypto.spec.PBEParameterSpec</code>
class can be used to initialize a Cipher object implementing
PBEWithMD5AndDES with a given salt and iteration count. </li>
          </ul>
          <p>Note that you do not have to worry about storing or
transferring any algorithm parameters for use by the decryption
operation if you use the <a href="#SealedObject"><code>SealedObject</code></a>
class. This class attaches the parameters used for sealing (encryption)
to the encrypted object contents, and uses the same parameters for
unsealing (decryption). </p>
        </blockquote>
        <h4>Cipher Output Considerations</h4>
        <blockquote>
          <p>Some of the <code>update</code> and <code>doFinal</code>
methods of Cipher allow the caller to specify the output buffer into
which to encrypt or decrypt the data. In these cases, it is important
to pass a buffer that is large enough to hold the result of the
encryption or decryption operation. </p>
          <p>The following method in Cipher can be used to determine
how big the output buffer should be: </p>
          <pre>    public int getOutputSize(int inputLen)<br></pre>
        </blockquote>
      </blockquote>
    </li>
    <li>
      <h2><a name="CipherStream">The Cipher Stream Classes</a></h2>
      <blockquote>
        <p>JCE introduces the concept of secure streams, which combine
an InputStream or OutputStream with a Cipher object. Secure streams are
provided by the <code>CipherInputStream</code> and <code>CipherOutputStream</code>
classes. </p>
        <blockquote>
          <ul>
            <li>
              <h3><a name="CipherInput">The CipherInputStream Class</a></h3>
              <blockquote>
                <p>This class is a <code>FilterInputStream</code> that
encrypts or decrypts the data passing through it. It is composed of an <code>InputStream</code>,
or one of its subclasses, and a <code>Cipher</code>. CipherInputStream
represents a secure input stream into which a Cipher object has been
interposed. The <code>read</code> methods of CipherInputStream return
data that are read from the underlying InputStream but have
additionally been processed by the embedded Cipher object. The Cipher
object must be fully initialized before being used by a
CipherInputStream. </p>
                <p>For example, if the embedded Cipher has been
initialized for decryption, the CipherInputStream will attempt to
decrypt the data it reads from the underlying InputStream before
returning them to the application. </p>
                <p>This class adheres strictly to the semantics,
especially the failure semantics, of its ancestor classes <code>java.io.FilterInputStream</code>
and <code>java.io.InputStream</code>. This class has exactly those
methods specified in its ancestor classes, and overrides them all, so
that the data are additonally processed by the embedded cipher.
Moreover, this class catches all exceptions that are not thrown by its
ancestor classes. In particular, the <code>skip(long)</code> method
skips only data that has been processed by the Cipher. </p>
                <p>It is crucial for a programmer using this class not
to use methods that are not defined or overridden in this class (such
as a new method or constructor that is later added to one of the super
classes), because the design and implementation of those methods are
unlikely to have considered security impact with regard to
CipherInputStream. </p>
                <p>As an example of its usage, suppose <code>cipher1</code>
has been initialized for encryption. The code below demonstrates how to
use a CipherInputStream containing that cipher and a FileInputStream in
order to encrypt input stream data: </p>
                <pre>    FileInputStream fis;<br>    FileOutputStream fos;<br>    CipherInputStream cis;<br><br>    fis = new FileInputStream("/tmp/a.txt");<br>    cis = new CipherInputStream(fis, cipher1);<br>    fos = new FileOutputStream("/tmp/b.txt");<br>    byte[] b = new byte[8];<br>    int i = cis.read(b);<br>    while (i != -1) {<br>        fos.write(b, 0, i);<br>        i = cis.read(b);<br>    }<br></pre>
                <p>The above program reads and encrypts the content
from the file <code>/tmp/a.txt</code> and then stores the result (the
encrypted bytes) in <code>/tmp/b.txt</code>. </p>
                <p>The following example demonstrates how to easily
connect several instances of CipherInputStream and FileInputStream. In
this example, assume that <code>cipher1</code> and <code>cipher2</code>
have been initialized for encryption and decryption (with corresponding
keys), respectively. </p>
                <pre>    FileInputStream fis;<br>    FileOutputStream fos;<br>    CipherInputStream cis1, cis2;<br><br>    fis = new FileInputStream("/tmp/a.txt");<br>    cis1 = new CipherInputStream(fis, cipher1);<br>    cis2 = new CipherInputStream(cis1, cipher2);<br>    fos = new FileOutputStream("/tmp/b.txt");<br>    byte[] b = new byte[8];<br>    int i = cis2.read(b);<br>    while (i != -1) {<br>        fos.write(b, 0, i);<br>        i = cis2.read(b);<br>    }<br></pre>
                <p>The above program copies the content from file <code>/tmp/a.txt</code>
to <code>/tmp/b.txt</code>, except that the content is first encrypted
and then decrypted back when it is read from <code>/tmp/a.txt</code>.
Of course since this program simply encrypts text and decrypts it back
right away, it's actually not very useful except as a simple way of
illustrating chaining of CipherInputStreams. </p>
              </blockquote>
            </li>
            <li>
              <h3><a name="CipherOutput">The CipherOutputStream Class</a></h3>
              <blockquote>
                <p>This class is a <code>FilterOutputStream</code>
that encrypts or decrypts the data passing through it. It is composed
of an <code>OutputStream</code>, or one of its subclasses, and a <code>Cipher</code>.
CipherOutputStream represents a secure output stream into which a
Cipher object has been interposed. The <code>write</code> methods of
CipherOutputStream first process the data with the embedded Cipher
object before writing them out to the underlying OutputStream. The
Cipher object must be fully initialized before being used by a
CipherOutputStream. </p>
                <p>For example, if the embedded Cipher has been
initialized for encryption, the CipherOutputStream will encrypt its
data, before writing them out to the underlying output stream. </p>
                <p>This class adheres strictly to the semantics,
especially the failure semantics, of its ancestor classes <code>java.io.OutputStream</code>
and <code>java.io.FilterOutputStream</code>. This class has exactly
those methods specified in its ancestor classes, and overrides them
all, so that all data are additionally processed by the embedded
cipher. Moreover, this class catches all exceptions that are not thrown
by its ancestor classes. </p>
                <p>It is crucial for a programmer using this class not
to use methods that are not defined or overridden in this class (such
as a new method or constructor that is later added to one of the super
classes), because the design and implementation of those methods are
unlikely to have considered security impact with regard to
CipherOutputStream. </p>
                <p>As an example of its usage, suppose <code>cipher1</code>
has been initialized for encryption. The code below demonstrates how to
use a CipherOutputStream containing that cipher and a FileOutputStream
in order to encrypt data to be written to an output stream: </p>
                <pre>    FileInputStream fis;<br>    FileOutputStream fos;<br>    CipherOutputStream cos;<br><br>    fis = new FileInputStream("/tmp/a.txt");<br>    fos = new FileOutputStream("/tmp/b.txt");<br>    cos = new CipherOutputStream(fos, cipher1);<br>    byte[] b = new byte[8];<br>    int i = fis.read(b);<br>    while (i != -1) {<br>        cos.write(b, 0, i);<br>        i = fis.read(b);<br>    }<br>    cos.flush();<br></pre>
                <p>The above program reads the content from the file <code>/tmp/a.txt</code>,
then encrypts and stores the result (the encrypted bytes) in <code>/tmp/b.txt</code>.
                </p>
                <p>The following example demonstrates how to easily
connect several instances of CipherOutputStream and FileOutputStream.
In this example, assume that <code>cipher1</code> and <code>cipher2</code>
have been initialized for decryption and encryption (with corresponding
keys), respectively: </p>
                <pre>    FileInputStream fis;<br>    FileOutputStream fos;<br>    CipherOutputStream cos1, cos2;<br><br>    fis = new FileInputStream("/tmp/a.txt");<br>    fos = new FileOutputStream("/tmp/b.txt");<br>    cos1 = new CipherOutputStream(fos, cipher1);<br>    cos2 = new CipherOutputStream(cos1, cipher2);<br>    byte[] b = new byte[8];<br>    int i = fis.read(b);<br>    while (i != -1) {<br>        cos2.write(b, 0, i);<br>        i = fis.read(b);<br>    }<br>    cos2.flush();<br></pre>
                <p>The above program copies the content from file <code>/tmp/a.txt</code>
to <code>/tmp/b.txt</code>, except that the content is first encrypted
and then decrypted back before it is written to <code>/tmp/b.txt</code>.
                </p>
                <p>There is one important difference between the <code>flush</code>
and <code>close</code> methods of this class, which becomes even more
relevant if the encapsulated Cipher object implements a block cipher
algorithm with padding turned on: </p>
                <p><code>flush</code> flushes the underlying
OutputStream by forcing any buffered output bytes that have already
been processed by the encapsulated Cipher object to be written out. Any
bytes buffered by the encapsulated Cipher object and waiting to be
processed by it will <b>not</b> be written out. </p>
                <p><code>close</code> closes the underlying
OutputStream and releases any system resources associated with it. It
invokes the <code>doFinal</code> method of the encapsulated Cipher
object, causing any bytes buffered by it to be processed and written
out to the underlying stream by calling its <code>flush</code> method.
                </p>
              </blockquote>
            </li>
          </ul>
        </blockquote>
      </blockquote>
    </li>
    <li>
      <h2><a name="KeyGenerator">The KeyGenerator Class</a></h2>
      <blockquote>
        <p>A key generator is used to generate secret keys for
symmetric algorithms. </p>
        <h4>Creating a Key Generator</h4>
        <blockquote>
          <p>Like other engine classes in the API, KeyGenerator objects
are created using the <code>getInstance</code> factory methods of the
KeyGenerator class. A factory method is a static method that returns an
instance of a class, in this case, an instance of <code>KeyGenerator</code>
which provides an implementation of the requested key generator. </p>
          <p><code>getInstance</code> takes as its argument the name of
a symmetric algorithm for which a secret key is to be generated.
Optionally, a package provider name may be specified: </p>
          <pre>    public static KeyGenerator getInstance(String algorithm);<br><br>    public static KeyGenerator getInstance(String algorithm,<br>                                           String provider);<br></pre>
          <p>If just an algorithm name is specified, the system will
determine if there is an implementation of the requested key generator
available in the environment, and if there is more than one, if there
is a preferred one. </p>
          <p>If both an algorithm name and a package provider are
specified, the system will determine if there is an implementation of
the requested key generator in the package requested, and throw an
exception if there is not. </p>
        </blockquote>
        <h4>Initializing a KeyGenerator Object</h4>
        <blockquote>
          <p>A key generator for a particular symmetric-key algorithm
creates a symmetric key that can be used with that algorithm. It also
associates algorithm-specific parameters (if any) with the generated
key. </p>
          <p>There are two ways to generate a key: in an
algorithm-independent manner, and in an algorithm-specific manner. The
only difference between the two is the initialization of the object: </p>
          <p> </p>
          <ul>
            <li><b>Algorithm-Independent Initialization</b>
              <p>All key generators share the concepts of a <i>keysize</i>
and a <i>source of randomness</i>. There is an <code>init</code>
method that takes these two universally shared types of arguments.
There is also one that takes just a <code>keysize</code> argument, and
uses a system-provided source of randomness, and one that takes just a
source of randomness: </p>
              <pre>    public void init(SecureRandom random);<br><br>    public void init(int keysize);<br><br>    public void init(int keysize, SecureRandom random);<br></pre>
              <p>Since no other parameters are specified when you call
the above algorithm-independent <code>init</code> methods, it is up to
the provider what to do about the algorithm-specific parameters (if
any) to be associated with the generated key. </p>
              <p></p>
            </li>
            <li><b>Algorithm-Specific Initialization</b>
              <p>For situations where a set of algorithm-specific
parameters already exists, there are two <code>init</code> methods
that have an <code>AlgorithmParameterSpec</code> argument. One also
has a <code>SecureRandom</code> argument, while the source of
randomness is system-provided for the other: </p>
              <pre>    public void init(AlgorithmParameterSpec params);<br><br>    public void init(AlgorithmParameterSpec params,<br>                     SecureRandom random);<br></pre>
            </li>
          </ul>
          <p>In case the client does not explicitly initialize the
KeyGenerator (via a call to an <code>init</code> method), each
provider must supply (and document) a default initialization. </p>
        </blockquote>
        <h4>Creating a Key</h4>
        <blockquote>The following method generates a secret key:
          <pre>    public SecretKey generateKey();<br></pre>
        </blockquote>
      </blockquote>
    </li>
    <li>
      <h2><a name="SecretFactory">The SecretKeyFactory Class</a></h2>
      <blockquote>
        <p>This class represents a factory for secret keys. </p>
        <p>Key factories are used to convert <i>keys</i> (opaque
cryptographic keys of type <code>java.security.Key</code>) into <i>key
specifications</i> (transparent representations of the underlying key
material in a suitable format), and vice versa. </p>
        <p>A <code>javax.crypto.SecretKeyFactory</code> object
operates only on secret (symmetric) keys, whereas a <code>java.security.KeyFactory</code>
object processes the public and private key components of a key pair. </p>
        <p>Objects of type <code>java.security.Key</code>, of which <code>java.security.PublicKey</code>,
        <code>java.security.PrivateKey</code>, and <code>javax.crypto.SecretKey</code>
are subclasses, are opaque key objects, because you cannot tell how
they are implemented. The underlying implementation is
provider-dependent, and may be software or hardware based. Key
factories allow providers to supply their own implementations of
cryptographic keys. </p>
        <p>For example, if you have a key specification for a Diffie
Hellman public key, consisting of the public value <code>y</code>, the
prime modulus <code>p</code>, and the base <code>g</code>, and you
feed the same specification to Diffie-Hellman key factories from
different providers, the resulting <code>PublicKey</code> objects will
most likely have different underlying implementations. </p>
        <p>A provider should document the key specifications supported
by its secret key factory. For example, the <code>SecretKeyFactory</code>
for DES keys supplied by the "SunJCE" provider supports <code>DESKeySpec</code>
as a transparent representation of DES keys, the <code>SecretKeyFactory</code>
for DES-EDE keys supports <code>DESedeKeySpec</code> as a transparent
representation of DES-EDE keys, and the <code>SecretKeyFactory</code>
for PBE supports <code>PBEKeySpec</code> as a transparent
representation of the underlying password. </p>
        <p>The following is an example of how to use a <code>SecretKeyFactory</code>
to convert secret key data into a <code>SecretKey</code> object, which
can be used for a subsequent <code>Cipher</code> operation: </p>
        <pre>    // Note the following bytes are not realistic secret key data <br>    // bytes but are simply supplied as an illustration of using data<br>    // bytes (key material) you already have to build a DESKeySpec.<br>    byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03, <br>        (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 };<br>    DESKeySpec desKeySpec = new DESKeySpec(desKeyData);<br>    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");<br>    SecretKey secretKey = keyFactory.generateSecret(desKeySpec);<br></pre>
        <p>In this case, the underlying implementation of <code>secretKey</code>
is based on the provider of <code>keyFactory</code>. </p>
        <p>An alternative, provider-independent way of creating a
functionally equivalent <code>SecretKey</code> object from the same
key material is to use the <code>javax.crypto.spec.SecretKeySpec</code>
class, which implements the <code>javax.crypto.SecretKey</code>
interface: </p>
        <pre>    byte[] desKeyData = { (byte)0x01, (byte)0x02, ...};<br>    SecretKeySpec secretKey = new SecretKeySpec(desKeyData, "DES");<br></pre>
      </blockquote>
    </li>
    <li>
      <h2><a name="SealedObject">The SealedObject Class</a></h2>
      <blockquote>
        <p>This class enables a programmer to create an object and
protect its confidentiality with a cryptographic algorithm. </p>
        <p>Given any object that implements the <code>java.io.Serializable</code>
interface, one can create a <code>SealedObject</code> that
encapsulates the original object, in serialized format (i.e., a "deep
copy"), and seals (encrypts) its serialized contents, using a
cryptographic algorithm such as DES, to protect its confidentiality.
The encrypted content can later be decrypted (with the corresponding
algorithm using the correct decryption key) and de-serialized, yielding
the original object. </p>
        <p>A typical usage is illustrated in the following code
segment: In order to seal an object, you create a <code>SealedObject</code>
from the object to be sealed and a fully initialized <code>Cipher</code>
object that will encrypt the serialized object contents. In this
example, the String "This is a secret" is sealed using the DES
algorithm. Note that any algorithm parameters that may be used in the
sealing operation are stored inside of <code>SealedObject</code>: </p>
        <p></p>
        <pre>    // create Cipher object<br>    // Note: sKey is assumed to refer to an already-generated<br>    // secret DES key.<br>    Cipher c = Cipher.getInstance("DES");<br>    c.init(Cipher.ENCRYPT_MODE, sKey);<br><br>    // do the sealing<br>    SealedObject so = new SealedObject("This is a secret", c);<br></pre>
        <p>The original object that was sealed can be recovered in two
different ways: </p>
        <p> </p>
        <ul>
          <li>by using a <code>Cipher</code> object that has been
initialized with the exact same algorithm, key, padding scheme, etc.,
that were used to seal the object:
            <p></p>
            <pre>    c.init(Cipher.DECRYPT_MODE, sKey);<br>    try {<br>        String s = (String)so.getObject(c);<br>    } catch (Exception e) {<br>        // do something<br>    };<br></pre>
            <p>This approach has the advantage that the party who
unseals the sealed object does not require knowledge of the decryption
key. For example, after one party has initialized the cipher object
with the required decryption key, it could hand over the cipher object
to another party who then unseals the sealed object. </p>
            <p></p>
          </li>
          <li>by using the appropriate decryption key (since DES is a
symmetric encryption algorithm, we use the same key for sealing and
unsealing):
            <p></p>
            <pre>    try {<br>        String s = (String)so.getObject(sKey);<br>    } catch (Exception e) {<br>        // do something<br>    };<br></pre>
            <p>In this approach, the <code>getObject</code> method
creates a cipher object for the appropriate decryption algorithm and
initializes it with the given decryption key and the algorithm
parameters (if any) that were stored in the sealed object. This
approach has the advantage that the party who unseals the object does
not need to keep track of the parameters (e.g., the IV) that were used
to seal the object. </p>
          </li>
        </ul>
      </blockquote>
    </li>
    <li>
      <h2><a name="KeyAgreement">The KeyAgreement Class</a></h2>
      <blockquote>
        <p>The KeyAgreement class provides the functionality of a key
agreement protocol. The keys involved in establishing a shared secret
are created by one of the key generators (<code>KeyPairGenerator</code>
or <code>KeyGenerator</code>), a <code>KeyFactory</code>, or as a
result from an intermediate phase of the key agreement protocol. </p>
        <h4>Creating a KeyAgreement Object</h4>
        <blockquote>
          <p>Each party involved in the key agreement has to create a
KeyAgreement object. Like other engine classes in the API, KeyAgreement
objects are created using the <code>getInstance</code> factory methods
of the KeyAgreement class. A factory method is a static method that
returns an instance of a class, in this case, an instance of <code>KeyAgreement</code>
which provides the requested key agreement algorithm. </p>
          <p><code>getInstance</code> takes as its argument the name of
a key agreement algorithm. Optionally, a package provider name may be
specified: </p>
          <pre>    public static KeyAgreement getInstance(String algorithm);<br><br>    public static KeyAgreement getInstance(String algorithm,<br>                                           String provider);<br></pre>
          <p>If just an algorithm name is specified, the system will
determine if there is an implementation of the requested key agreement
available in the environment, and if there is more than one, if there
is a preferred one. </p>
          <p>If both an algorithm name and a package provider are
specified, the system will determine if there is an implementation of
the requested key agreement in the package requested, and throw an
exception if there is not. </p>
        </blockquote>
        <h4>Initializing a KeyAgreement Object</h4>
        <blockquote>
          <p>You initialize a KeyAgreement object with your private
information. In the case of Diffie-Hellman, you initialize it with your
Diffie-Hellman private key. Additional initialization information may
contain a source of randomness and/or a set of algorithm parameters.
Note that if the requested key agreement algorithm requires the
specification of algorithm parameters, and only a key, but no
parameters are provided to initialize the KeyAgreement object, the key
must contain the required algorithm parameters. (For example, the
Diffie-Hellman algorithm uses a prime modulus <code>p</code> and a
base generator <code>g</code> as its parameters.) </p>
          <p>To initialize a KeyAgreement object, call one of its <code>init</code>
methods: </p>
          <pre>    public void init(Key key);<br><br>    public void init(Key key, SecureRandom random);<br><br>    public void init(Key key, AlgorithmParameterSpec params);<br><br>    public void init(Key key, AlgorithmParameterSpec params,<br>                     SecureRandom random);<br></pre>
        </blockquote>
        <h4>Executing a KeyAgreement Phase</h4>
        <blockquote>
          <p>Every key agreement protocol consists of a number of
phases that need to be executed by each party involved in the key
agreement. </p>
          <p>To execute the next phase in the key agreement, call the <code>doPhase</code>
method: </p>
          <pre>    public Key doPhase(Key key, boolean lastPhase);<br></pre>
          <p>The <code>key</code> parameter contains the key to be
processed by that phase. In most cases, this is the public key of one
of the other parties involved in the key agreement, or an intermediate
key that was generated by a previous phase. <code>doPhase</code> may
return an intermediate key that you may have to send to the other
parties of this key agreement, so they can process it in a subsequent
phase. </p>
          <p>The <code>lastPhase</code> parameter specifies whether or
not the phase to be executed is the last one in the key agreeement: A
value of <code>FALSE</code> indicates that this is not the last phase
of the key agreement (there are more phases to follow), and a value of <code>TRUE</code>
indicates that this is the last phase of the key agreement and the key
agreement is completed, i.e., <code>generateSecret</code> can be
called next. </p>
          <p>In the example of Diffie-Hellman between two parties (see <a
 href="#AppF">Appendix F</a>), you call <code>doPhase</code> once,
with <code>lastPhase</code> set to <code>TRUE</code>. In the example
of Diffie-Hellman between three parties, you call <code>doPhase</code>
twice: the first time with <code>lastPhase</code> set to <code>FALSE</code>,
the 2nd time with <code>lastPhase</code> set to <code>TRUE</code>. </p>
        </blockquote>
        <h4>Generating the Shared Secret</h4>
        <blockquote>
          <p>After each party has executed all the required key
agreement phases, it can compute the shared secret by calling one of
the <code>generateSecret</code> methods: </p>
          <pre>    public byte[] generateSecret();<br><br>    public int generateSecret(byte[] sharedSecret, int offset);<br><br>    public SecretKey generateSecret(String algorithm);<br></pre>
        </blockquote>
      </blockquote>
    </li>
    <li>
      <h2><a name="Mac">The Mac Class</a></h2>
      <blockquote>
        <p>The Mac class provides the functionality of a Message
Authentication Code (MAC). Please refer to the <a href="#HmacEx">code
example</a> in Appendix F. </p>
        <h4>Creating a Mac Object</h4>
        <blockquote>
          <p>Like other engine classes in the API, Mac objects are
created using the <code>getInstance</code> factory methods of the Mac
class. A factory method is a static method that returns an instance of
a class, in this case, an instance of <code>Mac</code> which provides
the requested MAC algorithm. </p>
          <p><code>getInstance</code> takes as its argument the name of
a MAC algorithm. Optionally, a package provider name may be specified: </p>
          <pre>    public static Mac getInstance(String algorithm);<br><br>    public static Mac getInstance(String algorithm,<br>                                  String provider);<br></pre>
          <p>If just an algorithm name is specified, the system will
determine if there is an implementation of the requested MAC algorithm
available in the environment, and if there is more than one, if there
is a preferred one. </p>
          <p>If both an algorithm name and a package provider are
specified, the system will determine if there is an implementation of
the requested MAC algorithm in the package requested, and throw an
exception if there is not. </p>
        </blockquote>
        <h4>Initializing a Mac Object</h4>
        <blockquote>
          <p>A Mac object is always initialized with a (secret) key and
may optionally be initialized with a set of parameters, depending on
the underlying MAC algorithm. </p>
          <p>To initialize a Mac object, call one of its <code>init</code>
methods: </p>
          <pre>    public void init(Key key);<br><br>    public void init(Key key, AlgorithmParameterSpec params);<br></pre>
          <p>You can initialize your Mac object with any (secret-)key
object that implements the <code>javax.crypto.SecretKey</code>
interface. This could be an object returned by <code>javax.crypto.KeyGenerator.generateKey()</code>,
or one that is the result of a key agreement protocol, as returned by <code>javax.crypto.KeyAgreement.generateSecret()</code>,
or an instance of <code>javax.crypto.spec.SecretKeySpec</code>. </p>
          <p>With some MAC algorithms, the (secret-)key algorithm
associated with the (secret-)key object used to initialize the Mac
object does not matter (this is the case with the HMAC-MD5 and
HMAC-SHA1 implementations of the SunJCE provider). With others,
however, the (secret-)key algorithm does matter, and an <code>InvalidKeyException</code>
is thrown if a (secret-)key object with an inappropriate (secret-)key
algorithm is used. </p>
        </blockquote>
        <h4>Computing a MAC</h4>
        <blockquote>
          <p>A MAC can be computed in one step (<i>single-part operation</i>)
or in multiple steps (<i>multiple-part operation</i>). A multiple-part
operation is useful if you do not know in advance how long the data is
going to be, or if the data is too long to be stored in memory all at
once. </p>
          <p>To compute the MAC of some data in a single step, call the
following <code>doFinal</code> method: </p>
          <pre>    public byte[] doFinal(byte[] input);<br></pre>
          <p>To compute the MAC of some data in multiple steps, call
one of the <code>update</code> methods: </p>
          <pre>    public void update(byte input);<br><br>    public void update(byte[] input);<br><br>    public void update(byte[] input, int inputOffset, int inputLen);<br></pre>
          <p>A multiple-part operation must be terminated by the above <code>doFinal</code>
method (if there is still some input data left for the last step), or
by one of the following <code>doFinal</code> methods (if there is no
input data left for the last step): </p>
          <pre>    public byte[] doFinal();<br><br>    public void doFinal(byte[] output, int outOffset);<br></pre>
        </blockquote>
      </blockquote>
    </li>
  </ul>
</blockquote>

<h1><a name="ExemptApps">How to Make Applications "Exempt" from
Cryptographic Restrictions</a></h1>
<blockquote>
  <blockquote><font color="red"><i>[Note 1: This section should be
ignored by most application developers. It is only for people whose
applications may be exported to those few countries whose governments
mandate cryptographic restrictions, if it desired that such
applications have fewer cryptographic restrictions than those mandated.
</i></font>
    <p></p>
  </blockquote>
  <blockquote><font color="red"><i>[Note 2: Throughout this section,
the term "application" is meant to encompass both applications and
applets.]</i> </font>
    <p></p>
  </blockquote>
  <p>The JCE framework within J2SE 5 includes an ability
to enforce restrictions regarding the cryptographic algorithms and
maximum cryptographic strengths available to applets/applications in
different jurisdiction contexts (locations). Any such restrictions are
specified in "jurisdiction policy files". </p>
  <p>Due to import control restrictions by the governments of a few
countries, the jurisdiction policy files shipped with the J2SE 5 
development kit 
from Sun Microsystems specify that "strong" but limited
cryptography may be used. An "unlimited strength" version of these
files indicating no restrictions on cryptographic strengths is
available for those living in eligible countries (which is most
countries). But only the "strong" version can be imported into those
countries whose governments mandate restrictions. The JCE framework
will enforce the restrictions specified in the installed jurisdiction
policy files. </p>
  <p>It is possible that the governments of some or all such countries
may allow certain applications to become exempt from some or all
cryptographic restrictions. For example, they may consider certain
types of applications as "special" and thus exempt. Or they may exempt
any application that utilizes an "exemption mechanism," such as key
recovery. Applications deemed to be exempt could get access to stronger
cryptography than that allowed for non-exempt applications in such
countries. </p>
  <p>In order for an application to be recognized as "exempt" at
runtime, it must meet the following conditions: </p>
  <ul>
    <li>It must have a permission policy file bundled with it in a JAR
file. The permission policy file specifies what cryptography-related
permissions the application has, and under what conditions (if any).
      <p></p>
    </li>
    <li>The JAR file containing the application and the permission
policy file must have been signed using a code-signing certificate
issued after the application was accepted as exempt. </li>
  </ul>
  <p>Below are sample steps required in order to make an application
exempt from some or all cryptographic restrictions. This is a basic
outline that includes information about what is required by JCE in
order to recognize and treat applications as being exempt. You will
need to know the exemption requirements of the particular country or
countries in which you would like your application to be able to be run
but whose governments require cryptographic restrictions. You will also
need to know the requirements of a JCE framework vendor that has a
process in place for handling exempt applications. Consult such a
vendor for further information. (Note: The SunJCE provider does not
supply an implementation of the ExemptionMechanismSpi class.) </p>
  <p> </p>
  <ul>
    <li>Step 1: Write and Compile Your Application Code
      <p></p>
    </li>
    <li>Step 2: Create a Permission Policy File Granting Appropriate
Cryptographic Permissions
      <p></p>
    </li>
    <li>Step 3: Prepare for Testing
      <p> </p>
      <blockquote> <li>Step 3a: Apply for Government Approval From the
Government Mandating Restrictions.
          <p></p>
        </li>
        <li>Step 3b: Get a Code-Signing Certificate
          <p></p>
        </li>
        <li>Step 3c: Bundle the Application and Permission Policy File
into a JAR file
          <p></p>
        </li>
        <li>Step 3d: Sign the JAR file
          <p></p>
        </li>
        <li>Step 3e: Set Up Your Environment Like That of a User in a
Restricted Country
          <p></p>
        </li>
        <li>Step 3f: (only for apps using exemption mechanisms) Install
a Provider Implementing the Exemption Mechanism Specified in the
Permission Policy File
          <p></p>
        </li>
      </blockquote>
    </li>
    <li>Step 4: Test Your Application
      <p></p>
    </li>
    <li>Step 5: Apply for U.S. Government Export Approval If Required
      <p></p>
    </li>
    <li>Step 6: Deploy Your Application
      <p></p>
    </li>
  </ul>
  <br>
  <h2>Special Code Requirements for Applications that Use Exemption
Mechanisms</h2>
  <blockquote>
    <p>When an application has a permission policy file associated with
it (in the same JAR file) and that permission policy file specifies an
exemption mechanism, then when the Cipher <code>getInstance</code>
method is called to instantiate a Cipher, the JCE code searches the
installed providers for one that implements the specified exemption
mechanism. If it finds such a provider, JCE instantiates an
ExemptionMechanism API object associated with the provider's
implementation, and then associates the ExemptionMechanism object with
the Cipher returned by <code>getInstance</code>. </p>
    <p>After instantiating a Cipher, and prior to initializing it (via
a call to the Cipher <code>init</code> method), your code must call
the following Cipher method: </p>
    <pre>    public ExemptionMechanism getExemptionMechanism()<br></pre>
    <p>This call returns the ExemptionMechanism object associated with
the Cipher. You must then initialize the exemption mechanism
implementation by calling the following method on the returned
ExemptionMechanism: </p>
    <pre>     public final void init(Key key)<br></pre>
    <p>The argument you supply should be the same as the argument of
the same types that you will subsequently supply to a Cipher <code>init</code>
method. </p>
    <p>Once you have initialized the ExemptionMechanism, you can
proceed as usual to initialize and use the Cipher. </p>
  </blockquote>
  <h2>Permission Policy Files </h2>
  <blockquote>
    <p>In order for an application to be recognized at runtime as being
"exempt" from some or all cryptographic restrictions, it must have a
permission policy file bundled with it in a JAR file. The permission
policy file specifies what cryptography-related permissions the
application has, and under what conditions (if any). </p>
    <p><font color="red"><i>Note: The permission policy file bundled
with an application must be named <b><code>cryptoPerms</code></b>.</i></font>
    </p>
    <p>The format of a permission entry in a permission policy file
that accompanies an exempt application is the same as the format for a
jurisdiction policy file downloaded with the JDK, which 
is: </p>
    <blockquote>
      <pre>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;<br>    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;<br>    [, &lt;AlgorithmParameterSpec class name&gt;,<br>    &lt;parameters for constructing an AlgorithmParameterSpec object&gt;]]]];<br></pre>
    </blockquote>
    <p>See <a href="#AppD">Appendix D</a> for more information about
the jurisdiction policy file format. </p>
    <h3>Permission Policy Files for Exempt Applications</h3>
    <blockquote>
      <p>Some applications may be allowed to be completely
unrestricted. Thus, the permission policy file that accompanies such an
application usually just needs to contain the following: </p>
      <blockquote>
        <pre>grant {<br>    // There are no restrictions to any algorithms.<br>    permission javax.crypto.CryptoAllPermission;<br>};<br></pre>
      </blockquote>
      <p>If an application just uses a single algorithm (or several
specific algorithms), then the permission policy file could simply
mention that algorithm (or algorithms) explicitly, rather than granting
CryptoAllPermission. For example, if an application just uses the
Blowfish algorithm, the permission policy file doesn't have to grant
CryptoAllPermission to all algorithms. It could just specify that there
is no cryptographic restriction if the Blowfish algorithm is used. In
order to do this, the permission policy file would look like the
following: </p>
      <blockquote>
        <pre>grant {<br>    permission javax.crypto.CryptoPermission "Blowfish";<br>};<br></pre>
      </blockquote>
    </blockquote>
    <h3>Permission Policy Files for Applications Exempt Due to
Exemption Mechanisms</h3>
    <blockquote>
      <p>If an application is considered "exempt" if an exemption
mechanism is enforced, then the permission policy file that accompanies
the application must specify one or more exemption mechanisms. At
runtime, the application will be considered exempt if any of those
exemption mechanisms is enforced. Each exemption mechanism must be
specified in a permission entry that looks like the following: </p>
      <blockquote>
        <pre>    // No algorithm restrictions if specified<br>    // exemption mechanism is enforced.<br>    permission javax.crypto.CryptoPermission *, <br>        "&lt;ExemptionMechanismName&gt;";<br></pre>
      </blockquote>
      <p>where <code>&lt;ExemptionMechanismName&gt;</code> specifies
the name of an exemption mechanism. The list of possible exemption
mechanism names includes: </p>
      <ul>
        <li>KeyRecovery
          <p></p>
        </li>
        <li>KeyEscrow
          <p></p>
        </li>
        <li>KeyWeakening </li>
      </ul>
As an example, suppose your application is exempt if either key
recovery or key escrow is enforced. Then your permission policy file
should contain the following:
      <blockquote>
        <pre>grant {<br>    // No algorithm restrictions if KeyRecovery is enforced.<br>    permission javax.crypto.CryptoPermission *, <br>        "KeyRecovery";<br>    // No algorithm restrictions if KeyEscrow is enforced.<br>    permission javax.crypto.CryptoPermission *, <br>        "KeyEscrow";<br>};<br></pre>
      </blockquote>
      <p>Note: Permission entries that specify exemption mechanisms
should <i>not</i> also specify maximum key sizes. The allowed key
sizes are actually determined from the installed exempt jurisdiction
policy files, as described in the next section. </p>
    </blockquote>
    <h3>How Bundled Permission Policy Files Affect Cryptographic
Permissions</h3>
    <blockquote>
      <p>At runtime, when an application instantiates a Cipher (via a
call to its <code>getInstance</code> method) and that application has
an associated permission policy file, JCE checks to see whether the
permission policy file has an entry that applies to the algorithm
specified in the <code>getInstance</code> call. If it does, and the
entry grants CryptoAllPermission or does not specify that an exemption
mechanism must be enforced, it means there is no cryptographic
restriction for this particular algorithm. </p>
      <p>If the permission policy file has an entry that applies to the
algorithm specified in the <code>getInstance</code> call and the entry
      <i>does</i> specify that an exemption mechanism must be enforced,
then the exempt jurisdiction policy file(s) are examined. If the exempt
permissions include an entry for the relevant algorithm and exemption
mechanism, and that entry is implied by the permissions in the
permission policy file bundled with the application, and if there is an
implementation of the specified exemption mechanism available from one
of the registered providers, then the maximum key size and algorithm
parameter values for the Cipher are determined from the exempt
permission entry. </p>
      <p>If there is no exempt permission entry implied by the relevant
entry in the permission policy file bundled with the application, or if
there is no implementation of the specified exemption mechanism
available from any of the registered providers, then the application is
only allowed the standard default cryptographic permissions. </p>
    </blockquote>
  </blockquote>
</blockquote>

<!--Removed JCE Provider Info and placed in new Provider doc-->

<H1><a name="Examples">Code Examples</a></H1>

<blockquote>


<H3><a name="MDEx">Computing a <code>MessageDigest</code> Object</a></H3>

<blockquote>

<P>
First create the <a href = "#MessageDigest">message digest</a> object, as in the following example:
<P>

<blockquote>
<pre>
MessageDigest sha = MessageDigest.getInstance("SHA-1");
</pre>
</blockquote>

This call assigns a properly initialized message digest object
to the <code>sha</code> variable. The implementation implements the Secure
Hash Algorithm (SHA-1), as defined in the National Institute for
Standards and Technology's (NIST) FIPS 180-1 document. See 
<a href = "#AppA">Appendix A</a> for a complete discussion of 
standard names and algorithms.

<P>
Next, suppose we have three byte arrays, <code>i1</code>, <code>i2</code>
and <code>i3</code>, which form the total input whose message digest we
want to compute. This digest (or "hash") could be calculated via the
following calls:

<blockquote>
<pre>
sha.update(i1);
sha.update(i2);
sha.update(i3);
byte[] hash = sha.digest();
</pre>
</blockquote>

<P>
An equivalent alternative series of calls would be:

<blockquote>
<pre>
sha.update(i1);
sha.update(i2);
byte[] hash = sha.digest(i3);
</pre>
</blockquote>
After the message digest has been calculated, the message digest object 
is automatically reset and ready to receive new data and calculate its 
digest. All former state (i.e., the data supplied to <code>update</code> 
calls) is lost.

<P>
Some hash implementations may support intermediate hashes through
cloning. Suppose we want to calculate separate hashes for:

<ul>
<li><code>i1</code>
<li><code>i1 and i2</code>
<li><code>i1, i2, and i3</code>

</ul>

<p>
A way to do it is:

<blockquote>
<pre>
/* compute the hash for i1 */
sha.update(i1); 
byte[] i1Hash = sha.clone().digest();

/* compute the hash for i1 and i2 */
sha.update(i2); 
byte[] i12Hash = sha.clone().digest(); 

/* compute the hash for i1, i2 and i3 */
sha.update(i3); 
byte[] i123hash = sha.digest();
</pre>
</blockquote>

This code works only if the SHA-1 implementation 
is cloneable. While some implementations of message digests are cloneable, 
others are not. To determine whether or not cloning is possible, attempt
to clone the <code>MessageDigest</code> object and catch the
potential exception as follows:

<blockquote>
<pre>
try {
    // try and clone it
    /* compute the hash for i1 */
    sha.update(i1); 
    byte[] i1Hash = sha.clone().digest();
    . . .
    byte[] i123hash = sha.digest();
} catch (CloneNotSupportedException cnse) {
    // do something else, such as the code shown below
}
</pre>
</blockquote>

If a message digest is not cloneable, the other, less elegant
way to compute intermediate digests is to create several digests. 
In this case, the number of intermediate digests
to be computed must be known in advance:

<blockquote>
<pre>
<code>MessageDigest</code> sha1 = MessageDigest.getInstance("SHA-1");
<code>MessageDigest</code> sha12 = MessageDigest.getInstance("SHA-1"); 
<code>MessageDigest</code> sha123 = MessageDigest.getInstance("SHA-1");

byte[] i1Hash = sha1.digest(i1);

sha12.update(i1);
byte[] i12Hash = sha12.digest(i2);

sha123.update(i1);
sha123.update(i2);
byte[] i123Hash = sha123.digest(i3);
</pre>
</blockquote>


</blockquote>


<H3><a name="KPGEx">Generating a Pair of Keys</a></H3>

<blockquote>

<P>
In this example we will generate a public-private key pair for the
algorithm named
"DSA" (Digital Signature Algorithm). We will generate keys
with a 1024-bit modulus, using a user-derived seed, 
called <code>userSeed</code>. We don't care which provider supplies
the algorithm implementation.

<H4>Creating the <a href = "#KPG">Key Pair Generator</a></H4>

<blockquote>

<P>
The first step is to get a key pair generator object for generating
keys for the DSA algorithm:
<blockquote>
<pre>
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
</pre>
</blockquote>
</blockquote>

<H4>Initializing the Key Pair Generator</H4>

<blockquote>

The next step is to initialize the key pair generator. In most cases,
algorithm-independent initialization is sufficient, but in some
cases, algorithm-specific initialization is used.

<H5>Algorithm-Independent Initialization</H5>

<P>
All key pair generators share the concepts of a keysize and a
source of randomness. A <code>KeyPairGenerator</code> class 
<code>initialize</code> method has these two types of arguments. Thus,
to generate keys with a keysize of 1024 and a new
<a href = "#SecureRandom"><code>SecureRandom</code></a> object seeded by 
the <code>userSeed</code> value, you can
use the following code: 

<blockquote>
<pre>
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
random.setSeed(userSeed);
keyGen.initialize(1024, random);
</pre>
</blockquote>

Since no other parameters are specified when you call the above
algorithm-independent <code>initialize</code>
method, it is up to the provider what to do about the algorithm-specific
parameters (if any) to be associated with each of the keys.
The provider may use precomputed parameter values or may
generate new values.

    
<H5>Algorithm-Specific Initialization</H5>

<p>For situations where a set of algorithm-specific parameters already
exists (such as "community parameters" in DSA),
there are two <code>initialize</code> methods that have an 
<a href = "#AlgorithmParameterSpec"><code>AlgorithmParameterSpec</code></a> argument.
Suppose your key pair generator is for the "DSA" algorithm, and you have a 
set of DSA-specific parameters, <code>p</code>, 
<code>q</code>, and <code>g</code>, that you would like to 
use to generate your key pair. You could execute the following code
to initialize your key pair generator (recall that 
<a href = "#DSAParameterSpec"><code>DSAParameterSpec</code></a> 
is an AlgorithmParameterSpec):

<blockquote>
<pre>
DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g);
SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
random.setSeed(userSeed);
keyGen.initialize(dsaSpec, random);
</pre>
</blockquote>

<blockquote>
<hr>
<b>Note:</B> The parameter named <code>p</code> is a prime 
number whose length is the modulus length ("size"). Therefore, 
you don't need to call any other method to
specify the modulus length.
<hr>
</blockquote>

</blockquote>


<H4>Generating the Pair of Keys</H4>

<blockquote>

The final step is generating the key pair. No matter which type of
initialization was used (algorithm-independent or 
algorithm-specific), the same code is used to generate the
<a href = "#KeyPair">key pair</a>:

<blockquote>
<pre>
KeyPair pair = keyGen.generateKeyPair();
</pre>
</blockquote>

</blockquote>

</blockquote>



<H3><a name="SigEx">Generating and Verifying a Signature Using Generated Keys</a></H3>

<blockquote>

<p>The following signature generation and verification examples
use the key pair generated in the <a href = "#KPGEx">key pair example</a>
above.


<H4>Generating a Signature</H4>

<blockquote>

<P>
We first create a <a href = "#Signature">signature</a> object:

<blockquote>
<pre>
Signature dsa = Signature.getInstance("SHA1withDSA"); 
</pre>
</blockquote>

Next, using the key pair generated in the 
key pair example, we initialize
the object with the private key, then sign a byte array called
<code>data</code>.

<blockquote>
<pre>
/* Initializing the object with a private key */
PrivateKey priv = pair.getPrivate();
dsa.initSign(priv);

/* Update and sign the data */
dsa.update(data);
byte[] sig = dsa.sign();
</pre>
</blockquote>


</blockquote>

<H4><a name="VerifyEx">Verifying a Signature</a></H4>

<blockquote>

Verifying the signature is straightforward. (Note that here we also use
the key pair generated in the key pair example.)

<blockquote>
<pre>
/* Initializing the object with the public key */
PublicKey pub = pair.getPublic();
dsa.initVerify(pub);

/* Update and verify the data */
dsa.update(data);
boolean verifies = dsa.verify(sig);
System.out.println("signature verifies: " + verifies);
</pre>
</blockquote>

</blockquote>

</blockquote>

<H3><a name="KeyFactoryEx">Generating/Verifying Signatures Using Key 
Specifications and <code>KeyFactory</code></a></H3>

<blockquote>

Suppose that, rather than having a public/private key pair (as, for example, was
generated in the <a href = "#KPGEx">key pair example</a> above), 
you simply have the components of 
your DSA private key: <code>x</code> (the private
key), <code>p</code> (the prime), <code>q</code> (the sub-prime), 
and <code>g</code> (the base).

<p>Further suppose you want to use your private key to digitally sign 
some data, which is in a byte array named <code>someData</code>.
You would do the following steps, which also illustrate creating a
key specification and using a key
factory to obtain a <code>PrivateKey</code> from the key specification
(<code>initSign</code> requires a <code>PrivateKey</code>):

<blockquote>
<pre>
DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g);

KeyFactory keyFactory = KeyFactory.getInstance("DSA");
PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec);

Signature sig = Signature.getInstance("SHA1withDSA");
sig.initSign(privKey);
sig.update(someData);
byte[] signature = sig.sign();
</pre>
</blockquote>

Suppose Alice wants to use the data you signed. In order for her to
do so, and to verify your signature, you need to send her three things:

<ol>

<li>the data,

<li>the signature, and

<li>the public key corresponding to the private key you used to sign
the data.

</ol>

You can store the <code>someData</code> bytes in one file, and
the <code>signature</code> bytes in another, and send those to Alice. 

<p>For the public key,
assume, as in the signing example above, you have the components of the 
DSA public key
corresponding to the DSA private key used to sign the data. Then you can 
create a DSAPublicKeySpec from those components:

<blockquote>
<pre>
DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g);
</pre>
</blockquote>

You still need to extract the key bytes so that you can put
them in a file. To do so, you can first call the <code>generatePublic</code> method
on the DSA key factory already created
in the example above:

<blockquote>
<pre>
PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec);
</pre>
</blockquote>

Then you can extract the (encoded) key bytes via the following:

<blockquote>
<pre>
byte[] encKey = pubKey.getEncoded();
</pre>
</blockquote>        

You can now store these bytes in a file, and send it to Alice along with
the files containing the data and the signature. 

<p>Now, assume Alice has received these files, and she copied the data
bytes from the data file to a byte array named <code>data</code>, the signature
bytes from the signature file to a byte array named <code>signature</code>,
and the encoded public key bytes from the public key file to a byte
array named <code>encodedPubKey</code>.

<P>Alice can now execute the following code to verify the
signature. The code also illustrates how to use a key factory in order to
instantiate a DSA public key from its encoding (<code>initVerify</code>
requires a <code>PublicKey</code>).

<pre>
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);

    Signature sig = Signature.getInstance("SHA1withDSA");
    sig.initVerify(pubKey);
    sig.update(data);
    sig.verify(signature);
</pre>

Note: In the above, Alice needed to generate a <code>PublicKey</code> from the
encoded key bits, since <code>initVerify</code> requires a <code>PublicKey</code>.
Once she has a <code>PublicKey</code>, she could also use the <code>KeyFactory</code>
<code>getKeySpec</code> method to convert it to a <code>DSAPublicKeySpec</code> so that 
she can access the components, if desired, as in:

<pre>
    DSAPublicKeySpec dsaPubKeySpec =
        (DSAPublicKeySpec)keyFactory.getKeySpec(pubKey,
            DSAPublicKeySpec.class)
</pre>

Now she can access the DSA public key components <code>y</code>, 
<code>p</code>, <code>q</code>, and <code>g</code> through the 
corresponding "get" methods on the <code>DSAPublicKeySpec</code> class 
(<code>getY</code>, <code>getP</code>, <code>getQ</code>, and 
<code>getG</code>).

</blockquote>


<a name = "Equal"></a>
<H3>Determining If Two Keys Are Equal</H3>
<blockquote>

<P>
 In many cases you would like to know if two keys are equal; however,  
the default method <code>java.lang.Object.equals</code> may not give the 
desired result. The most provider-independent approach is to compare the 
encoded keys. If this comparison isn't appropriate (for example, when  
comparing an <code>RSAPrivateKey</code> and an <code>RSAPrivateCrtKey</code>), 
you should compare each component. The following code demonstrates this idea: 

<blockquote>
<pre>
static boolean keysEqual(Key key1, Key key2) {
    if (key1.equals(key2)) {
        return true;
    }
 
    if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) {
        return true;
    }

    // More code for different types of keys here.
    // For example, the following code can check if
    // an RSAPrivateKey and an RSAPrivateCrtKey are equal:
    // if ((key1 instanceof RSAPrivateKey) &&
    //     (key2 instanceof RSAPrivateKey)) {
    //     if ((key1.getModulus().equals(key2.getModulus())) &&
    //         (key1.getPrivateExponent().equals(
    //                                      key2.getPrivateExponent()))) {
    //         return true;
    //     }
    // }

    return false;
}
</pre>
</blockquote>
</blockquote>


<H3><a name="ReadCert">Reading Base64-Encoded Certificates</a></H3>

<blockquote>

<p>The following example reads a file with Base64-encoded certificates,
which are each bounded at the beginning by 

<pre>
-----BEGIN CERTIFICATE-----
</pre>

and at the end by 

<pre>
-----END CERTIFICATE-----
</pre>

We convert the
<code>FileInputStream</code> (which does not support <code>mark</code>
and <code>reset</code>) to a <code>ByteArrayInputStream</code> (which
supports those methods), so that each call to
<code>generateCertificate</code> consumes only one certificate, and the
read position of the input stream is positioned to the next certificate in
the file:<p>

<pre>
FileInputStream fis = new FileInputStream(filename);
BufferedInputStream bis = new BufferedInputStream(fis);

CertificateFactory cf = CertificateFactory.getInstance("X.509");

while (bis.available() > 0) {
    Certificate cert = cf.generateCertificate(bis);
    System.out.println(cert.toString());
}
</pre>

</blockquote>


<H3><a name="ParseCert">Parsing a Certificate Reply</a></H3>

<blockquote>

<p>The following example parses a PKCS #7-formatted certificate reply stored
in a file and extracts all the certificates from it:<p>

<pre>
FileInputStream fis = new FileInputStream(filename);
CertificateFactory cf = CertificateFactory.getInstance("X.509");
Collection c = cf.generateCertificates(fis);
Iterator i = c.iterator();
while (i.hasNext()) {
   Certificate cert = (Certificate)i.next();
   System.out.println(cert);
}
</pre>

</blockquote>

  <p>This section is a short tutorial on how to use some of the major
features of the JCE APIs in J2SE 5. Complete sample
programs that exercise the APIs can be found in <a href="#AppF">Appendix
F</a> of this document. </p>
  <h2><a name="SimpleEncrEx">Using Encryption</a></h2>
  <blockquote>
    <p>This section takes the user through the process of generating a
key, creating and initializing a cipher object, encrypting a file, and
then decrypting it. Throughout this example, we use the Data Encryption
Standard (DES). </p>
    <h4>Generating a Key</h4>
    <blockquote>
      <p>To create a DES key, we have to instantiate a KeyGenerator for
DES. We do not specify a provider, because we do not care about a
particular DES key generation implementation. Since we do not
initialize the KeyGenerator, a system-provided source of randomness
will be used to create the DES key: </p>
      <pre>    KeyGenerator keygen = KeyGenerator.getInstance("DES");<br>    SecretKey desKey = keygen.generateKey();<br></pre>
      <p>After the key has been generated, the same KeyGenerator object
can be re-used to create further keys. </p>
    </blockquote>
    <h4>Creating a Cipher</h4>
    <blockquote>
      <p>The next step is to create a Cipher instance. To do this, we
use one of the <code>getInstance</code> factory methods of the Cipher
class. We must specify the name of the requested transformation, which
includes the following components, separated by slashes (/): </p>
      <ul>
        <li>the algorithm name </li>
        <li>the mode (optional) </li>
        <li>the padding scheme (optional) </li>
      </ul>
      <p>In this example, we create a DES (Data Encryption Standard)
cipher in Electronic Codebook mode, with PKCS #5-style padding. We do
not specify a provider, because we do not care about a particular
implementation of the requested transformation. </p>
      <p>The standard algorithm name for DES is "DES", the standard
name for the Electronic Codebook mode is "ECB", and the standard name
for PKCS #5-style padding is "PKCS5Padding": </p>
      <pre>    Cipher desCipher;<br><br>    // Create the cipher <br>    desCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");<br></pre>
      <p>We use the generated <code>desKey</code> from above to
initialize the Cipher object for encryption: </p>
      <pre>    // Initialize the cipher for encryption<br>    desCipher.init(Cipher.ENCRYPT_MODE, desKey);<br><br>    // Our cleartext<br>    byte[] cleartext = "This is just an example".getBytes();<br><br>    // Encrypt the cleartext<br>    byte[] ciphertext = desCipher.doFinal(cleartext);<br><br>    // Initialize the same cipher for decryption<br>    desCipher.init(Cipher.DECRYPT_MODE, desKey);<br><br>    // Decrypt the ciphertext<br>    byte[] cleartext1 = desCipher.doFinal(ciphertext);<br></pre>
      <p><code>cleartext</code> and <code>cleartext1</code> are
identical. </p>
    </blockquote>
  </blockquote>
  <h2><a name="PBEEx">Using Password-Based Encryption</a></h2>
  <blockquote>
    <p>In this example, we prompt the user for a password from which we
derive an encryption key. </p>
    <p>It would seem logical to collect and store the password in an
object of type <code>java.lang.String</code>. However, here's the
caveat: Objects of type <code>String</code> are immutable, i.e., there
are no methods defined that allow you to change (overwrite) or zero out
the contents of a <code>String</code> after usage. This feature makes <code>String</code>
objects unsuitable for storing security sensitive information such as
user passwords. You should always collect and store security sensitive
information in a char array instead. </p>
    <p>For that reason, the <code>javax.crypto.spec.PBEKeySpec</code>
class takes (and returns) a password as a char array. </p>
    <p>The following method is an example of how to collect a user
password as a char array: </p>
    <pre>    /**<br>     * Reads user password from given input stream.<br>     */<br>    public char[] readPasswd(InputStream in) throws IOException {<br>        char[] lineBuffer;<br>        char[] buf;<br>        int i;<br><br>        buf = lineBuffer = new char[128];<br><br>        int room = buf.length;<br>        int offset = 0;<br>        int c;<br><br>loop:   while (true) {<br>            switch (c = in.read()) {<br>              case -1: <br>              case '\n':<br>                break loop;<br><br>              case '\r':<br>                int c2 = in.read();<br>                if ((c2 != '\n') &amp;&amp; (c2 != -1)) {<br>                    if (!(in instanceof PushbackInputStream)) {<br>                        in = new PushbackInputStream(in);<br>                    }<br>                    ((PushbackInputStream)in).unread(c2);<br>                } else <br>                    break loop;<br><br>              default:<br>                if (--room &lt; 0) {<br>                    buf = new char[offset + 128];<br>                    room = buf.length - offset - 1;<br>                    System.arraycopy(lineBuffer, 0, buf, 0, offset);<br>                    Arrays.fill(lineBuffer, ' ');<br>                    lineBuffer = buf;<br>                }<br>                buf[offset++] = (char) c;<br>                break;<br>            }<br>        }<br><br>        if (offset == 0) {<br>            return null;<br>        }<br><br>        char[] ret = new char[offset];<br>        System.arraycopy(buf, 0, ret, 0, offset);<br>        Arrays.fill(buf, ' ');<br><br>        return ret;<br>    }<br></pre>
    <p>In order to use Password-Based Encryption (PBE) as defined in
PKCS #5, we have to specify a <i>salt</i> and an <i>iteration count</i>.
The same salt and iteration count that are used for encryption must be
used for decryption: </p>
    <pre>    PBEKeySpec pbeKeySpec;<br>    PBEParameterSpec pbeParamSpec;<br>    SecretKeyFactory keyFac;<br><br>    // Salt<br>    byte[] salt = {<br>        (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,<br>        (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99<br>    };<br><br>    // Iteration count<br>    int count = 20;<br><br>    // Create PBE parameter set<br>    pbeParamSpec = new PBEParameterSpec(salt, count);<br><br>    // Prompt user for encryption password.<br>    // Collect user password as char array (using the<br>    // "readPasswd" method from above), and convert<br>    // it into a SecretKey object, using a PBE key<br>    // factory.<br>    System.out.print("Enter encryption password:  ");<br>    System.out.flush();<br>    pbeKeySpec = new PBEKeySpec(readPasswd(System.in));<br>    keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");<br>    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);<br><br>    // Create PBE Cipher<br>    Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");<br><br>    // Initialize PBE Cipher with key and parameters<br>    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);<br><br>    // Our cleartext<br>    byte[] cleartext = "This is another example".getBytes();<br><br>    // Encrypt the cleartext<br>    byte[] ciphertext = pbeCipher.doFinal(cleartext);<br></pre>
  </blockquote>
  <h2><a name="KeyAgreeEx">Using Key Agreement</a></h2>
  <blockquote>
    <p>Please refer to <a href="#AppF">Appendix F</a> for sample
programs exercising the Diffie-Hellman key exchange between 2 and 3
parties, respectively. </p>
  </blockquote>


</blockquote>

</blockquote>




<HR>


<H1><a name="AppA">Appendix A: Standard Names</a></H1>

<blockquote>

<P>
The Java 2 SDK Security API requires and uses a set of standard names
for algorithms, certificate and keystore types. This specification
establishes the following names as standard names.  

<p>In some cases naming conventions are suggested for forming names that 
are not explicitly listed, to facilitate name consistency across
provider implementations. 
Such suggestions use items in angle brackets
(such as &lt;digest&gt; and &lt;encryption&gt;)
as placeholders to be replaced by specific message digest, encryption algorithm, 
and other names.

<blockquote>
<hr>
<B>Note:</B> Algorithm names are not case-sensitive.
<hr>
</blockquote>

This appendix includes corresponding lists of standard names relevant to the 
various security subareas:

<ul>
<li><a href="certpath/CertPathProgGuide.html#AppA">
<b>Java Certification Path API Programmer's Guide</b></a> <p>

<li><a href="jce/JCERefGuide.html#AppA"><b>
JCE Reference Guide</b></a> <p>

<li><a href="jsse/JSSERefGuide.html#AppA"><b>JSSE Reference Guide</b></a>

</ul>

<p>See <a href="#AppB">Appendix B</A> for algorithm specifications.

<H3>Message Digest Algorithms</H3>

<blockquote>

<P>
The algorithm names in this section can be specified when
generating an instance of <code>MessageDigest</code>.
<P>
<b>MD2</b>: The MD2 message digest algorithm as defined in RFC 1319.
<P>
<b>MD5</b>: The MD5 message digest algorithm as defined in RFC 1321.

<P>
<b>SHA-1</b>: The Secure Hash Algorithm, as defined in Secure
Hash Standard, NIST FIPS 180-1.

<P>
<b>SHA-256</b>, <b>SHA-384</b>, and <b>SHA-512</b>: New hash algorithms for 
which the 
<A HREF="http://csrc.nist.gov/encryption/shs/dfips-180-2.pdf">
draft Federal Information Processing Standard 180-2, 
<I>Secure Hash Standard (SHS)</I></A> 
is now available. 
SHA-256 is a 256-bit hash function intended to provide 128 bits of
security against collision attacks, while SHA-512 is a 512-bit
hash function intended to provide 256 bits of security.
A 384-bit hash may be obtained by truncating the SHA-512 output.

</blockquote>

<H3>Key and Parameter Algorithms</H3>

<blockquote>

<P>
The algorithm names in this section can be specified when
generating an instance of <code>KeyPairGenerator</code>,
<code>KeyFactory</code>, <code>AlgorithmParameterGenerator</code>, and
<code>AlgorithmParameters</code>.
<P>
<b>DSA</b>: The Digital Signature Algorithm as defined in FIPS PUB 186.
<P>
<b>RSA</b>: The RSA encryption algorithm as defined in PKCS #1.

</blockquote>

<H3>Digital Signature Algorithms</H3>

<blockquote>

<P>
The algorithm names in this section can be specified when
generating an instance of <code>Signature</code>.
<P>
<B>ECDSA</B> (Elliptic Curve Digital Signature Algorithm), an authentication
     mechanism described in 
     <A href="http://www.ietf.org/internet-drafts/draft-ietf-tls-ecc-05.txt">ECC 
     Cipher Suites for TLS</a> (January 2004 draft).
<P>
<b>MD2withRSA</b>: The MD2 with RSA Encryption signature algorithm
which uses the MD2 digest algorithm and RSA to create and verify RSA
digital signatures as defined in PKCS #1.
<P>
<b>MD5withRSA</b>: The MD5 with RSA Encryption signature algorithm
which uses the MD5 digest algorithm and RSA to create and verify RSA
digital signatures as defined in PKCS #1.
<P>
<b>NONEwithDSA</b>: This signature algorithm accepts direct raw data to be
signed and uses DSA to create and verify DSA
digital signatures as defined in FIPS PUB 186. The data
must be exactly 20 bytes in length. This algorithms is
also known under the alias name of RawDSA.
<P>
<b>SHA1withDSA</b>: The DSA with SHA-1 signature algorithm which uses the
SHA-1 digest algorithm and DSA to create and verify DSA digital
signatures as defined in FIPS PUB 186.
<P>
<b>SHA1withRSA</b>: The signature algorithm with SHA-1 and the RSA encryption 
algorithm as defined in the OSI Interoperability Workshop, using the
padding conventions described in PKCS #1.

<P>
<b>&lt;digest&gt;with&lt;encryption&gt;</b>: Use this to form a name for a
signature algorithm with a particular message digest (such as MD2 or MD5) and
algorithm (such as RSA or DSA), just as was done for the explicitly-defined
standard names in this section (MD2withRSA, etc.).
For the new signature schemes defined in PKCS #1 v 2.0, for which the
&lt;digest&gt;with&lt;encryption&gt; form is insufficient,
<b>&lt;digest&gt;with&lt;encryption&gt;and&lt;mgf&gt;</b> can be used to
form a name. Here,
&lt;mgf&gt; should be replaced by a mask generation function such as MGF1.
Example: MD5withRSAandMGF1.

</blockquote>

<H3>Random Number Generation (RNG) Algorithms</H3>

<blockquote>

<P>
The algorithm names in this section can be
specified when generating an instance of <code>SecureRandom</code>.
<P>
<b>SHA1PRNG</b>: The name of the pseudo-random number generation
(PRNG) algorithm supplied by the SUN provider. This implementation
follows the IEEE P1363 standard, Appendix G.7: "Expansion of source
bits", and uses SHA-1 as the foundation of the PRNG. It computes the
SHA-1 hash over a true-random seed value concatenated with a 64-bit
counter which is incremented by 1 for each operation. From the 160-bit
SHA-1 output, only 64 bits are used.

</blockquote>

<H3>Certificate Types</H3>

<blockquote>

<P>
The types in this section can be specified when generating an
instance of <code>CertificateFactory</code>.
<P>
<b>X.509</b>: The certificate type defined in X.509.

</blockquote>

<H3>Keystore Types</H3>

<blockquote>
<P>
The types in this section can be specified when generating an
instance of <code>KeyStore</code>.
<P>
<b>JKS</b>: The name of the keystore implementation provided by the
SUN provider.
<P>
<b>PKCS12</b>: The transfer syntax for personal identity information
as defined in PKCS #12.
</blockquote>

<H3>Service Attributes</H3>
<blockquote>
A cryptographic service is always associated with a particular
        algorithm or type. For example, a digital signature service is
        always associated with a particular algorithm (e.g., DSA),
        and a <code>CertificateFactory</code> service is always associated with
        a particular certificate type (e.g., X.509).
<P>
The attributes in this section are for cryptographic services.
        The service attributes can be used as filters for selecting
providers.  
<P>
Both the attribute name and value are case insensitive.
<P>
<b>KeySize</b>: The maximum key size that the provider supports for
        the cryptographic service. 
<P>
<b>ImplementedIn</b>: Whether the implementation for the cryptographic 
        service is done by software or hardware. The value of this
        attribute 
is "software" or "hardware".

</blockquote>
  <p>The JCE API requires and utilizes a set of standard names for
algorithms, algorithm modes, and padding schemes. This specification
establishes the following names as standard names. It supplements the
list of standard names defined in <a href="CryptoSpec.html#AppA">Appendix
A</a> in the <i>Java<sup><font size="-2">TM</font></sup> Cryptography
Architecture API Specification &amp; Reference</i>. Note that algorithm
names are treated case-insensitively. </p>
  <p>In some cases naming conventions are suggested for forming names
that are not explicitly listed, to facilitate name consistency across
provider implementations. Such suggestions use items in angle brackets
(such as &lt;digest&gt; and &lt;encryption&gt;) as placeholders to be
replaced by specific message digest, encryption algorithm, and other
names. </p>
  <h2>Cipher</h2>
  <blockquote>
    <h4>Algorithm</h4>
    <blockquote>
      <p>The following names can be specified as the <i>algorithm</i>
component in a <a href="#trans">transformation</a> when requesting an
instance of <code><big><b>Cipher</b></big></code>: </p>
      <p> </p>
      <ul>
        <li><b>AES</b>: Advanced Encryption Standard as specified by
NIST in a draft FIPS. Based on the Rijndael algorithm by Joan Daemen
and Vincent Rijmen, AES is a 128-bit block cipher supporting keys of
128, 192, and 256 bits.
          <p></p>
        </li>
        <li><b>ARCFOUR/RC4</b>: A stream cipher developed by Ron
Rivest. For more information, see K. Kaukonen and R. Thayer, "A Stream
Cipher Encryption Algorithm 'Arcfour'", Internet Draft (expired),
          <a
 href="http://www.mozilla.org/projects/security/pki/nss/draft-kaukonen-cipher-arcfour-03.txt">draft-kaukonen-cipher-arcfour-03.txt</a>.
          <p></p>
        </li>
        <li><b>Blowfish</b>: The block cipher designed by Bruce
Schneier.
          <p></p>
        </li>
        <li><b>DES</b>: The Digital Encryption Standard as described in
FIPS PUB 46-2.
          <p></p>
        </li>
        <li><b>DESede</b>: Triple DES Encryption (DES-EDE).
          <p></p>
        </li>
        <li><b>ECIES (Elliptic Curve Integrated Encryption Scheme)</b>
          <p></p>
        </li>
        <li><b>PBEWith&lt;digest&gt;And&lt;encryption&gt;</b> or <b>PBEWith&lt;prf&gt;And&lt;encryption&gt;</b>:
The password-based encryption algorithm (PKCS #5), using the specified
message digest (&lt;digest&gt;) or pseudo-random function (&lt;prf&gt;)
and encryption algorithm (&lt;encryption&gt;). Examples:
          <p> </p>
          <ul>
            <li><b>PBEWithMD5AndDES</b>: The password-based encryption
algorithm as defined in: RSA Laboratories, "PKCS #5: Password-Based
Encryption Standard," version 1.5, Nov 1993. Note that this algorithm
implies <a href="#cbcMode"><i>CBC</i></a> as the cipher mode and <a
 href="#pkcs5Pad"><i>PKCS5Padding</i></a> as the padding scheme and
cannot be used with any other cipher modes or padding schemes.
              <p></p>
            </li>
            <li><b>PBEWithHmacSHA1AndDESede</b>: The password-based
encryption algorithm as defined in: RSA Laboratories, "PKCS #5:
Password-Based Cryptography Standard," version 2.0, March 1999. </li>
          </ul>
          <p></p>
        </li>
        <li><b>RC2</b>, <b>RC4</b>, and <b>RC5</b>: Variable-key-size
encryption algorithms developed by Ron Rivest for RSA Data Security,
Inc.
          <p></p>
        </li>
        <li><b>RSA</b>: The RSA encryption algorithm as defined in PKCS
#1. </li>
      </ul>
    </blockquote>
    <h4>Mode</h4>
    <blockquote>
      <p>The following names can be specified as the <i>mode</i>
component in a <a href="#trans">transformation</a> when requesting an
instance of <code><big><b>Cipher</b></big></code>: </p>
      <p> </p>
      <ul>
        <li><b>NONE</b>: No mode.
          <p></p>
        </li>
        <li><b><a name="cbcMode">CBC</a></b>: Cipher Block Chaining
Mode, as defined in FIPS PUB 81.
          <p></p>
        </li>
        <li><b>CFB</b>: Cipher Feedback Mode, as defined in FIPS PUB
81.
          <p></p>
        </li>
        <li><b>ECB</b>: Electronic Codebook Mode, as defined in: The
National Institute of Standards and Technology (NIST) Federal
Information Processing Standard (FIPS) PUB 81, "DES Modes of
Operation," U.S. Department of Commerce, Dec 1980.
          <p></p>
        </li>
        <li><b>OFB</b>: Output Feedback Mode, as defined in FIPS PUB
81.
          <p></p>
        </li>
        <li><b>PCBC</b>: Propagating Cipher Block Chaining, as defined
by Kerberos V4. </li>
      </ul>
    </blockquote>
    <h4>Padding</h4>
    <blockquote>
      <p>The following names can be specified as the <i>padding</i>
component in a <a href="#trans">transformation</a> when requesting an
instance of <code><big><b>Cipher</b></big></code>: </p>
      <p> </p>
      <ul>
        <li><b>ISO10126Padding</b>. This padding for block ciphers is
described in <a href="http://www.w3.org/TR/xmlenc-core/#sec-Alg-Block">5.2
Block Encryption Algorithms</a> in the W3C's "XML Encryption Syntax and
Processing" document.
          <p></p>
        </li>
        <li><b>NoPadding</b>: No padding.
          <p></p>
        </li>
        <li><b>OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding</b>: Optimal
Asymmetric Encryption Padding scheme defined in PKCS #1, where
&lt;digest&gt; should be replaced by the message digest and &lt;mgf&gt;
by the mask generation function. Example: OAEPWithMD5AndMGF1Padding.
          <p></p>
        </li>
        <li><b><a name="pkcs5Pad">PKCS5Padding</a></b>: The padding
scheme described in: RSA Laboratories, "PKCS #5: Password-Based
Encryption Standard," version 1.5, November 1993.
          <p></p>
        </li>
        <li><b>SSL3Padding</b>: The padding scheme defined in the SSL
Protocol Version 3.0, November 18, 1996, section 5.2.3.2 (CBC block
cipher):
          <pre>    block-ciphered struct {<br>        opaque content[SSLCompressed.length];<br>        opaque MAC[CipherSpec.hash_size];<br>        uint8 padding[GenericBlockCipher.padding_length];<br>        uint8 padding_length;<br>    } GenericBlockCipher;<br></pre>
          <p>The size of an instance of a GenericBlockCipher must be a
multiple of the block cipher's block length. </p>
          <p>The padding length, which is always present, contributes
to the padding, which implies that if: </p>
          <pre>    sizeof(content) + sizeof(MAC) % block_length = 0,<br></pre>
padding has to be (block_length - 1) bytes long, because of the
existence of <code>padding_length</code>.
          <p>This make the padding scheme similar (but not quite) to
PKCS5Padding, where the padding length is encoded in the padding (and
ranges from 1 to block_length). With the SSL scheme, the
sizeof(padding) is encoded in the always present <code>padding_length</code>
and therefore ranges from 0 to block_length-1. </p>
          <p>Note that this padding mechanism is not supported by the
"SunJCE" provider. </p>
        </li>
      </ul>
    </blockquote>
  </blockquote>
  <h2>KeyAgreement</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>KeyAgreement</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>DiffieHellman</b>: Diffie-Hellman Key Agreement as defined
in PKCS #3: Diffie-Hellman Key-Agreement Standard, RSA Laboratories,
version 1.4, November 1993. </li>
      <p></p>
      <li><b>ECDH</b> (Elliptic Curve Diffie-Hellman) as described in <a
 href="http://www.ietf.org/rfc/rfc3278.txt">RFC 3278</a>: "Use of
Elliptic Curve Cryptography (ECC) Algorithms in Cryptographic Message
Syntax (CMS)."</li>
      <p></p>
      <li><b>ECMQV</b> (Elliptic Curve Menezes-Qu-Vanstone) as
described in <a
 href="http://www.ietf.org/internet-drafts/draft-ietf-tls-ecc-05.txt">ECC
Cipher Suites For TLS</a> (January 2004 draft).</li>
    </ul>
  </blockquote>
  <h2>KeyGenerator</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>KeyGenerator</b></big></code>: </p>
    <p></p>
    <ul>
      <li><b>AES</b>
        <p></p>
      </li>
      <li><b>ARCFOUR/RC4</b>
        <p></p>
      </li>
      <li><b>Blowfish</b>
        <p></p>
      </li>
      <li><b>DES</b>
        <p></p>
      </li>
      <li><b>DESede</b>
        <p></p>
      </li>
      <li><b>HmacMD5</b>
        <p></p>
      </li>
      <li><b>HmacSHA1</b> </li>
      <p></p>
      <li><b>HmacSHA256</b>
        <p></p>
      </li>
      <li><b>HmacSHA384</b>
        <p></p>
      </li>
      <li><b>HmacSHA512</b>
        <p></p>
      </li>
      <li><b>RC2</b>
        <p></p>
      </li>
    </ul>
  </blockquote>
  <h2>KeyPairGenerator</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>KeyPairGenerator</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>DiffieHellman</b> </li>
    </ul>
  </blockquote>
  <h2>SecretKeyFactory</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>SecretKeyFactory</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>DES</b>
        <p></p>
      </li>
      <li><b>DESede</b>
        <p></p>
      </li>
      <li><b>PBEWith&lt;digest&gt;And&lt;encryption&gt;</b> or <b>PBEWith&lt;prf&gt;And&lt;encryption&gt;</b>:
Secret-key factory for use with PKCS #5 password-based encryption,
where &lt;digest&gt; is a message digest, &lt;prf&gt; is a
pseudo-random function, and &lt;encryption&gt; is an encryption
algorithm. Examples: <b>PBEWithMD5AndDES</b> (PKCS #5, v 1.5) and <b>PBEWithHmacSHA1AndDESede</b>
(PKCS #5, v 2.0). Note: These both use only the low order 8 bits of
each password character. </li>
    </ul>
  </blockquote>
  <h2>KeyFactory</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>KeyFactory</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>DiffieHellman</b> </li>
    </ul>
  </blockquote>
  <h2>AlgorithmParameterGenerator</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>AlgorithmParameterGenerator</b></big></code>:
    </p>
    <p> </p>
    <ul>
      <li><b>DiffieHellman</b> </li>
    </ul>
  </blockquote>
  <h2>AlgorithmParameters</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>AlgorithmParameters</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>AES</b>
        <p></p>
      </li>
      <li><b>Blowfish</b>
        <p></p>
      </li>
      <li><b>DES</b>
        <p></p>
      </li>
      <li><b>DESede</b>
        <p></p>
      </li>
      <li><b>DiffieHellman</b>
        <p></p>
      </li>
      <li><b>OAEP</b>
        <p></p>
      </li>
      <li><b>PBE</b> </li>
      <p></p>
      <li><b>PBEWith&lt;digest&gt;And&lt;encryption&gt;</b>
        <p></p>
      </li>
      <li><b>RC2</b>
        <p></p>
      </li>
    </ul>
  </blockquote>
  <h2>MAC</h2>
  <blockquote>
    <p>The following algorithm names can be specified when requesting
an instance of <code><big><b>Mac</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>HmacMD5</b>: The HMAC-MD5 keyed-hashing algorithm as
defined in RFC 2104: "HMAC: Keyed-Hashing for Message Authentication"
(February 1997).
        <p></p>
      </li>
      <li><b>HmacSHA1</b>: The HMAC-SHA1 keyed-hashing algorithm as
defined in RFC 2104: "HMAC: Keyed-Hashing for Message Authentication"
(February 1997).
        <p></p>
      </li>
      <li><b>HmacSHA256</b>: The HmacSHA256 algorithm as defined in <a
 href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> "HMAC:
Keyed-Hashing for Message Authentication" (February 1997) with <code>SHA-256</code>
as the message digest algorithm.
        <p></p>
      </li>
      <li><b>HmacSHA384</b>: The HmacSHA384 algorithm as defined in <a
 href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> "HMAC:
Keyed-Hashing for Message Authentication" (February 1997) with <code>SHA-384</code>
as the message digest algorithm.
        <p></p>
      </li>
      <li><b>HmacSHA512</b>: The HmacSHA512 algorithm as defined in <a
 href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> "HMAC:
Keyed-Hashing for Message Authentication" (February 1997) with <code>SHA-512</code>
as the message digest algorithm.
        <p></p>
      </li>
      <li><b>PBEWith&lt;mac&gt;</b>: MAC for use with PKCS #5 v 2.0
password-based message authentication standard, where &lt;mac&gt; is a
Message Authentication Code algorithm name. Example: PBEWithHmacSHA1. </li>
    </ul>
  </blockquote>
  <h2>Keystore Types</h2>
  <blockquote>
    <p>The following types can be specified when requesting an instance
of <code><big><b>KeyStore</b></big></code>: </p>
    <p> </p>
    <ul>
      <li><b>JCEKS</b>: The <a href="#JceKeystore">proprietary
keystore type</a> implemented by the "SunJCE" provider. </li>
    </ul>
  </blockquote>
<!--
  <H2>Signature</H2>
  <BLOCKQUOTE>
  <UL>
     <LI><B>ECDSA</B> (Elliptic Curve Digital Signature Algorithm)</LI>
  </UL>
   </BLOCKQUOTE>
-->
  <h2>Exemption Mechanisms</h2>
  <blockquote>
    <p>The following exemption mechanism names can be specified in the
permission policy file that accompanies an application considered
"exempt" from cryptographic restrictions: </p>
    <p> </p>
    <ul>
      <li><b>KeyEscrow</b>: An encryption system with a backup
decryption capability that allows authorized persons (users, officers
of an organization, and government officials), under certain prescribed
conditions, to decrypt ciphertext with the help of information supplied
by one or more trusted parties who hold special data recovery keys.
        <p></p>
      </li>
      <li><b>KeyRecovery</b>: A method of obtaining the secret key used
to lock encrypted data. One use is as a means of providing fail-safe
access to a corporation's own encrypted information in times of
disaster.
        <p></p>
      </li>
      <li><b>KeyWeakening</b>: A method in which a part of the key can
be escrowed or recovered. </li>
    </ul>
  </blockquote>
</blockquote>
<hr>
<h1><a name="AppB">Appendix B: SunJCE Default Keysizes</a></h1>
<blockquote>
  <p>The SunJCE provider uses the following default keysizes: </p>
  <ul>
    <li><b>KeyGenerator</b>
      <p> </p>
      <ul>
        <li><b>DES</b>: 56 bits
          <p></p>
        </li>
        <li><b>Triple DES</b>: 112 bits
          <p></p>
        </li>
        <li><b>Blowfish</b>: 56 bits
          <p></p>
        </li>
        <li><b>HmacMD5</b>: 64 bytes
          <p></p>
        </li>
        <li><b>HmacSHA1</b>: 64 bytes </li>
      </ul>
      <p></p>
    </li>
    <li><b>KeyPairGenerator</b>
      <p> </p>
      <ul>
        <li><b>Diffie-Hellman</b>: 1024 bits </li>
      </ul>
      <p></p>
    </li>
    <li><b>AlgorithmParameterGenerator</b>
      <p> </p>
      <ul>
        <li><b>Diffie-Hellman</b>: 1024 bits </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h1><a name="AppC">Appendix C: SunJCE Keysize Restrictions</a></h1>
<blockquote>
  <p>The SunJCE provider enforces the following restrictions on the
keysize passed to the initialization methods of the following classes: </p>
  <ul>
    <li><b>KeyGenerator</b>
      <p>Restrictions (by algorithm): </p>
      <p> </p>
      <ul>
        <li><b>DES</b>: keysize must be equal to <code>56</code>
          <p></p>
        </li>
        <li><b>Triple DES</b>: keysize must be equal to <code>112</code>
or <code>168</code>
          <p>Note: A keysize of <code>112</code> will generate a
Triple DES key with 2 intermediate keys, and a keysize of <code>168</code>
will generate a Triple DES key with 3 intermediate keys. </p>
          <p></p>
        </li>
        <li><b>Blowfish</b>: keysize must be a multiple of <code>8</code>,
and can only range from <code>32</code> to <code>448</code>,
inclusive </li>
      </ul>
      <p></p>
    </li>
    <li><b>KeyPairGenerator</b>
      <p>Restrictions (by algorithm): </p>
      <p> </p>
      <ul>
        <li><b>Diffie-Hellman</b>: keysize must be a multiple of <code>64</code>,
and can only range from <code>512</code> to <code>1024</code>,
inclusive </li>
      </ul>
      <p></p>
    </li>
    <li><b>AlgorithmParameterGenerator</b>
      <p>Restrictions (by algorithm): </p>
      <p> </p>
      <ul>
        <li><b>Diffie-Hellman</b>: keysize must be a multiple of <code>64</code>,
and can only range from <code>512</code> to <code>1024</code>,
inclusive </li>
      </ul>
    </li>
  </ul>
</blockquote>
<hr>
<h1><a name="AppD">Appendix D: Jurisdiction Policy File Format</a></h1>
<blockquote>
  <p>JCE represents its jurisdiction policy files as J2SE-style policy
files with corresponding permission statements. As described in <a
 href="PolicyFiles.html">Default
Policy Implementation and Policy File Syntax</a>, a J2SE policy file
specifies what permissions are allowed for code from specified code
sources. A permission represents access to a system resource. In the
case of JCE, the "resources" are cryptography algorithms, and code
sources do not need to be specified, because the cryptographic
restrictions apply to all code. </p>
  <p>A jurisdiction policy file consists of a very basic "grant entry"
containing one or more "permission entries." </p>
  <blockquote>
    <pre>grant {<br>    &lt;permission entries&gt;;<br>};<br></pre>
  </blockquote>
  <p>The format of a permission entry in a jurisdiction policy file is:
  </p>
  <blockquote>
    <pre>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;<br>    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;<br>    [, &lt;AlgorithmParameterSpec class name&gt;,<br>    &lt;parameters for constructing an <br>        AlgorithmParameterSpec object&gt;]]]];<br></pre>
  </blockquote>
  <p>A sample jurisdiction policy file that includes restricting the
"Blowfish" algorithm to maximum key sizes of 64 bits is: </p>
  <blockquote>
    <pre>grant {<br>    permission javax.crypto.CryptoPermission "Blowfish", 64;<br>    . . .;<br>};<br></pre>
  </blockquote>
  <p>A permission entry must begin with the word <code>permission</code>.
The <code>&lt;crypto permission class name&gt;</code> in the template
above would actually be a specific permission class name, such as <code>javax.crypto.CryptoPermission</code>.
A crypto permission class reflects the ability of an application/applet
to use certain algorithms with certain key sizes in certain
environments. There are two crypto permission classes: <code>CryptoPermission</code>
and <code>CryptoAllPermission</code>. The special <code>CryptoAllPermission</code>
class implies all cryptography-related permissions, that is, it
specifies that there are no cryptography-related restrictions. </p>
  <p>The &lt;alg_name&gt;, when utilized, is a quoted string specifying
the standard name (see <a href="#AppA">Appendix A</a>) of a
cryptography algorithm, such as "DES" or "RSA". </p>
  <p>The &lt;exemption mechanism name&gt;, when specified, is a quoted
string indicating an exemption mechanism which, if enforced, enables a
reduction in cryptographic restrictions. Exemption mechanism names that
can be used include "KeyRecovery" "KeyEscrow", and "KeyWeakening". </p>
  <p>&lt;maxKeySize&gt; is an integer specifying the maximum key size
(in bits) allowed for the specified algorithm. </p>
  <p>For some algorithms it may not be sufficient to specify the
algorithm strength in terms of just a key size. For example, in the
case of the "RC5" algorithm, the number of rounds must also be
considered. For algorithms whose strength needs to be expressed as more
than a key size, the permission entry should also specify an
AlgorithmParameterSpec class name (such as <code>javax.crypto.spec.RC5ParameterSpec</code>)
and a list of parameters for constructing the specified
AlgorithmParameterSpec object. </p>
  <p>Items that appear in a permission entry must appear in the
specified order. An entry is terminated with a semicolon. </p>
  <p>Case is unimportant for the identifiers (<code>grant</code>, <code>permission</code>)
but is significant for the <code>&lt;crypto permission class name&gt;</code>
or for any string that is passed in as a value. </p>
  <p>Note: An "*" can be used as a wildcard for any permission entry
option. For example, an "*" (without the quotes) for an
&lt;alg_name&gt; option means "all algorithms." </p>
</blockquote>
<hr>
<h1><a name="AppE">Appendix E: Maximum Key Sizes Allowed by "Strong"
Jurisdiction Policy Files</a></h1>
<blockquote>
  <p>Due to import control restrictions, the jurisdiction policy files
shipped with the J2SE 5 Development Kit allow "strong" but limited
cryptography to be used. Here are the maximum key sizes allowed by this
"strong" version of the jurisdiction policy files: </p>
  <p>
  <table summary="maximum key sizes">
    <tbody>
      <tr>
        <th>
        <p class="CellHeading">Algorithm </p>
        </th>
        <th>
        <p class="CellHeading">Maximum Key Size </p>
        </th>
      </tr>
      <tr>
        <td align="center">
        <p>DES </p>
        </td>
        <td align="center">
        <p>64 </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>DESede </p>
        </td>
        <td align="center">
        <p>* </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>RC2 </p>
        </td>
        <td align="center">
        <p>128 </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>RC4 </p>
        </td>
        <td align="center">
        <p>128 </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>RC5 </p>
        </td>
        <td align="center">
        <p>128 </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>RSA </p>
        </td>
        <td align="center">
        <p>2048 </p>
        </td>
      </tr>
      <tr>
        <td align="center">
        <p>* (all others) </p>
        </td>
        <td align="center">
        <p>128 </p>
        </td>
      </tr>
    </tbody>
  </table>
  </p>
</blockquote>
<hr>

<HR>

<H1><a name="AppB">Appendix B: Algorithms</a></H1>

<blockquote>

<p>This appendix specifies details concerning some of the algorithms
defined in Appendix A. Any provider supplying an implementation of the
listed algorithms must comply with the specifications in
this appendix. 

<blockquote>
<hr>
<B>Note:</B> The most recent version of this document is
available online at: 
<a href="index.html">
http://java.sun.com/j2se/1.5.0/docs/guide/security/index.html</a>.
<hr>
</blockquote>

<p>To add a new algorithm not specified here, you should first 
survey other people or companies supplying provider
packages to see if they
have already added that algorithm, and, if so, use
the definitions they published, if available. Otherwise, you
should create and make available a
template, similar to those found in this Appendix B, 
with the specifications for the algorithm you
provide. 

<H3>Specification Template</H3>

<blockquote>

The following table shows the fields of the algorithm specifications.

<blockquote>
<TABLE summary="algorithm specification fields" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="2">
  <thead>
  <TR>
    <TH WIDTH="23%" BGCOLOR="#dedeef">
    <B>Field</B> </TH>
    <TH WIDTH="77%" BGCOLOR="#dedeef">
    <B>Description</B></TH>
  </TR>
  </thead>
  <TR>
    <TD WIDTH="23%">
    Name</TD>
    <TD WIDTH="77%">
    The name by which the algorithm is known. This is the name passed
    to the <CODE>getInstance</CODE> method (when requesting the algorithm),
    and returned by the <CODE>getAlgorithm</CODE> method to determine
    the name of an existing algorithm object. These methods are in
    the relevant engine classes: <CODE><A HREF="#Signature">Signature</A></CODE>,
    <CODE><A HREF="#MessageDigest">MessageDigest</A></CODE>, <CODE><A
    HREF="#KPG">KeyPairGenerator</A></CODE>, and <CODE><A HREF="#AlgorithmParameterGenerator">AlgorithmParameterGenerator</A></CODE>.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    Type</TD>
    <TD WIDTH="77%">
    The type of algorithm: <CODE>Signature</CODE>, <CODE>MessageDigest</CODE>,
    <CODE>KeyPairGenerator</CODE>, or <CODE>ParameterGenerator</CODE>.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    Description</TD>
    <TD WIDTH="77%">
    General notes about the algorithm, including any standards implemented
    by the algorithm, applicable patents, etc.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    <CODE>KeyPair</CODE> Algorithm (<I>optional</I>)</TD>
    <TD WIDTH="77%">
    The keypair algorithm for this algorithm.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    Keysize (<I>optional</I>)</TD>
    <TD WIDTH="77%">
    For a keyed algorithm or key generation algorithm: the legal
    keysizes.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    <P>Size (<I>optional</I>)</TD>
    <TD WIDTH="77%">
    For an algorithm parameter generation algorithm: the legal &quot;sizes&quot;
    for algorithm parameter generation.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    <P>Parameter Defaults (<I>optional</I>)</TD>
    <TD WIDTH="77%">
    For a key generation algorithm: the default parameter values.</TD>
  </TR>
  <TR>
    <TD WIDTH="23%">
    <P><CODE>Signature</CODE> Format (<I>optional</I>)</TD>
    <TD WIDTH="77%">
    For a <CODE>Signature</CODE> algorithm, the format of the signature,
    that is, the input and output of the verify and sign methods,
    respectively.</TD>
  </TR>
</TABLE>
</blockquote>
</BLOCKQUOTE>

<H3>Algorithm Specifications</H3>

<blockquote>


<H4>SHA-1 Message Digest Algorithm</H4>

<BLOCKQUOTE>
  <TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Name</B></TD> 
      <TD WIDTH="72%">
      SHA-1</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>MessageDigest</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      The message digest algorithm as defined in NIST's FIPS
      180-1. The output of this algorithm is a 160-bit digest.</TD> 
    </TR>
  </TABLE>
</BLOCKQUOTE>

<H4>MD2 Message Digest Algorithm</H4>

<BLOCKQUOTE>
  <TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Name</B></TD> 
      <TD WIDTH="72%">
      MD2</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      &nbsp;<B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>MessageDigest</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      The message digest algorithm as defined in RFC 1319. The output
      of this algorithm is a 128-bit (16 byte) digest.</TD> 
    </TR>
  </TABLE>
</BLOCKQUOTE>

<H4>MD5 Message Digest Algorithm</H4>

<BLOCKQUOTE>
  <P><TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Name</B></TD> 
      <TD WIDTH="72%">
      MD5</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>MessageDigest</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      The message digest algorithm as defined in RFC 1321. The output
      of this algorithm is a 128-bit (16 byte) digest.</TD> 
    </TR>
  </TABLE>
</BLOCKQUOTE>

<H4>The Digital Signature Algorithm</H4>

<BLOCKQUOTE>
<TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Name</B></TD> 
      <TD WIDTH="72%">
      SHA1withDSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>Signature</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      This algorithm is the signature algorithm described in NIST FIPS
      186, using DSA with the SHA-1 message digest algorithm.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B><CODE>KeyPair</CODE> Algorithm</B></TD> 
      <TD WIDTH="72%">
      DSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Signature Format</B></TD> 
      <TD WIDTH="72%">
      ASN.1 sequence of two INTEGER values: <CODE>r</CODE> and <CODE>s</CODE>,
      in that order:<BR>
      <CODE>SEQUENCE ::= { r INTEGER, s INTEGER }</CODE></TD> 
    </TR>
  </TABLE></P>
</BLOCKQUOTE>

<H4>RSA-based Signature Algorithms, with MD2, MD5 or SHA-1</H4>

<BLOCKQUOTE>
  <P><TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Names</B></TD> 
      <TD WIDTH="72%">
      MD2withRSA, MD5withRSA and SHA1withRSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>Signature</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      These are the signature algorithms that use the MD2, MD5, and
      SHA-1 message digest algorithms (respectively) with RSA encryption.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B><CODE>KeyPair</CODE> Algorithm</B></TD> 
      <TD WIDTH="72%">
      <BLOCKQUOTE>
        RSA</BLOCKQUOTE>
</TD>
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Signature Format</B></TD> 
      <TD WIDTH="72%">
      DER-encoded PKCS #1 block as defined in RSA Laboratory's <I>Public
      Key Cryptography Standards Note #1</I>. The data encrypted is
      the digest of the data signed.</TD> 
    </TR>
  </TABLE>
  </BLOCKQUOTE>

  <H4>DSA KeyPair Generation Algorithm</H4>

<BLOCKQUOTE>
<TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%" HEIGHT="23">
      <B>Name</B></TD> 
      <TD WIDTH="72%" HEIGHT="23">
      DSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" HEIGHT="23">
      <B>Type</B></TD> 
      <TD WIDTH="72%" HEIGHT="23">
      <CODE>KeyPairGenerator</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP" HEIGHT="42">
      <B>Description</B></TD> 
      <TD WIDTH="72%" HEIGHT="42">
      This algorithm is the key pair generation algorithm described
      in NIST FIPS 186 for DSA.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" HEIGHT="41">
      <B>Keysize</B></TD> 
      <TD WIDTH="72%" HEIGHT="41">
      The length, in bits, of the modulus <CODE>p</CODE>. This must
      range from 512 to 1024, and must be a multiple of 64. The default
      keysize is 1024.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" HEIGHT="23" VALIGN="TOP">
      <B>Parameter Defaults</B></TD> 
      <TD WIDTH="72%" HEIGHT="23">
      <P>The following default parameter values are used for keysizes
      of 512, 768, and 1024 bits:</P>

      <H5>512-bit Key Parameters</H5>

      <PRE>SEED = b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
counter = 123
p = fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
    ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
    bdc43ee7 37592e17
q = 962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5
         
g = 678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
    14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
    6c416e50 be794ca4</PRE>

      <H5>768-bit key parameters</H5>

      <PRE>SEED = 77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
counter = 263
p = e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
    d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
    22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
    ee3688c1 1a8c56ab 127a3daf
q = 9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
g = 30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
    a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
    1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
    7064f316 933a346d 3f529252</PRE>

      <H5>1024-bit key parameters</H5>

      <PRE>SEED = 8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
counter = 92
p = fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
    b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
    801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
    1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
    f3ae2b61 d72aeff2 2203199d d14801c7
q = 9760508f 15230bcc b292b982 a2eb840b f0581cf5
         
g = f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
    3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
    b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
    0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
    928b665e 807b5525 64014c3b fecf492a</PRE>
</TD>
    </TR>
  </TABLE></P>
</BLOCKQUOTE>

<H4>RSA KeyPair Generation Algorithm</H4>

<BLOCKQUOTE>
  <P><TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Names</B></TD> 
      <TD WIDTH="72%">
      RSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>KeyPairGenerator</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      This algorithm is the key pair generation algorithm described
      in PKCS #1.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Strength</B></TD> 
      <TD WIDTH="72%">
        Any integer that is a multiple of 8, greater than or equal to
        512. 
</TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>

<H4>DSA Parameter Generation Algorithm</H4>

<BLOCKQUOTE>
  <TABLE summary="layout" WIDTH="700" BORDER="1" CELLSPACING="2" CELLPADDING="0">
    <TR>
      <TD WIDTH="28%">
      <B>Names</B></TD> 
      <TD WIDTH="72%">
      DSA</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%">
      <B>Type</B></TD> 
      <TD WIDTH="72%">
      <CODE>ParameterGenerator</CODE></TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Description</B></TD> 
      <TD WIDTH="72%">
      This algorithm is the parameter generation algorithm described
      in NIST FIPS 186 for DSA.</TD> 
    </TR>
    <TR>
      <TD WIDTH="28%" VALIGN="TOP">
      <B>Strength</B></TD> 
      <TD WIDTH="72%">
  
        The length, in bits, of the modulus <CODE>p</CODE>. This must
        range from 512 to 1024, and must be a multiple of 64. The default
        size is 1024.
</TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>

</BLOCKQUOTE>

</BLOCKQUOTE>

<h1><a name="AppF">Appendix F: Sample Programs</a></h1>
<ul>
  <li><a name="DH2Ex">
    <h3>Diffie-Hellman Key Exchange between 2 Parties</h3>
    </a>
